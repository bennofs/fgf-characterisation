%!TEX root = ../main.tex

\section{Tree-Like Unraveling}\label{sec:unraveling}
We next describe a notion of \emph{tree unravellings} for $\FGF$.
A ``truncated'' form of these unravellings will be employed afterwards in the construction of the companion structures required for~\cref{thm:main-technical-thm}.
The truncation is necessary to keep the structure finite, as tree unravellings of structures containing cycles are infinite.
This is similar to the approach taken by Otto to construct the finite companions for the van Benthem charactisation of modal logic with universal modalities~\cite[Proof of Lemma 38]{Otto04}.
Our approach is similar to the construction of finite companions in the van Benthem Characterisation of modal logic with universal modality by Otto~\cite[Proof of Lemma 38]{Otto04}.
However, novel ideas are required to make this construction applicable to the case of higher-arity relations.

Let $\str{A}$ be a structure with an associated binary relation $\relNext^{\str{A}}$.
For a pair $(\eleme_1, \eleme_2) \in \relNext^{\str{A}}$, we call the element $\eleme_2$ a \emph{child} of $\eleme_1$. Respectively, we call $\eleme_1$ a \emph{parent} of $\eleme_2$.
A \emph{root} is an element without parents.
The set of $\emph{descendants}$ of an element $\eleme$ is the smallest set containing $\eleme$ that is closed under taking children (\ie{} if an element is in the set then so are its children).
We call a structure $\str{A}$ a \emph{forest} if every element has at most one parent and is a descendant of some root.
A model is a tree model if it is a forest and has exactly one root.
It is well-known that with a suitable notion of unravelling~\cite[Prop. 3]{Rosen97} one can show that every satisfiable modal logic formula has a tree model.

Our goal is to design a notion of unravelling for $\FGF$ satisfying the following theorem:
\begin{theorem}\label{thm:inf-unraveling-upgrading}
  Let $\str{A}, \elemtuplea \bisimto_{\FGF} \str{B}, \elemtupleb$ for two pointed $\sigma$-structures.
  Then there are tree models $\unravel{A}, \elemtuptuplea$ and $\unravel{B}, \elemtuptupleb$ which are both:
  \begin{itemize}
    \item $\FGF$-similar to the original structures: $\unravel{A}, \elemtuptuplea \bisimto_{\FGF} \str{A}, \elemtuplea$ and $\unravel{B}, \elemtuptupleb \bisimto_{\FGF} \str{B}, \elemtupleb$
    \item $\GF$-bisimilar: $\unravel{A}, \elemtuptuplea \bisimto_{\GF} \unravel{B}, \elemtuptupleb$.
  \end{itemize}
\end{theorem}
The \emph{HAF}-unravelling~\cite[Sec 3.3]{Bednarczyk21} introduced by Bednarczyk produces a tree model which is \FGF-bisimilar to a given \FGF-model, but unfortunately fails to satisfy the above theorem.
Consider the two finite structures depicted in \cref{fig:unravel-haf}.
Both of them are identical to their HAF-unravelling as they are already HAFs.
Yet, they can be distinguished by a $\GF$ sentence $\exists{x,y}. \relE(x,y) \land \lnot (\exists z. \relP(x,y,z))$.
Since both structures are $\FGF$ bisimilar, this shows that HAF-unravellings do not satisfy \cref{thm:inf-unraveling-upgrading} even in the finite case.

\begin{figure}
  \centering
    \begin{tikzpicture}[baseline=(current bounding box.north)]
        \draw[tolbrightGreen, line cap=round, line width=2em] (-0em,8em) -- ++(0,-8em);
        \draw[tolbrightYellow, line cap=round, line width=0.5em, -{Latex[length=2em]}] (0,4em) -- (0,0em);

        \draw [black, line width=0.1em, fill=white] (0em, 8em) circle [radius=0.8em] node[anchor=center] {1};
        \draw [black, line width=0.1em, fill=white] (0em, 4em) circle [radius=0.8em] node[anchor=center] {2};
        \draw [black, line width=0.1em, fill=white] (0em, 0em) circle [radius=0.8em] node[anchor=center] {3};

        \begin{scope}[xshift=10em]
            \draw[tolbrightGreen, line cap=round, line width=2em] (-0em,8em) -- ++(0,-8em);
            \draw[tolbrightYellow, line cap=round, line width=0.5em, -{Latex[length=2em]}] (0em,4em) -> (6em,2em);
            \draw[tolbrightYellow, line cap=round, line width=0.5em, -{Latex[length=2em]}] (0,4em) -- (0,0em);

            \draw [black, line width=0.1em, fill=white] (0em, 8em) circle [radius=0.8em] node[anchor=center] {1};
            \draw [black, line width=0.1em, fill=white] (0em, 4em) circle [radius=0.8em] node[anchor=center] {2};
            \draw [black, line width=0.1em, fill=white] (0em, 0em) circle [radius=0.8em] node[anchor=center] {3};
            \draw [black, line width=0.1em, fill=white] (6em, 2em) circle [radius=0.8em] node[anchor=center] {3'};

            \node[tolbrightGreen] at (-2em, 6em) {P};
            \node[tolbrightYellow] at (-1.5em, 2em) {E};
            \node[tolbrightYellow] at (3em, 4em) {E};
        \end{scope}

        \node[font=\Large] at (5em, 4em) {$\sim_{FGF}$};

        \node[tolbrightGreen] at (-2em, 6em) {P};
        \node[tolbrightYellow] at (-1.5em, 2em) {E};
    \end{tikzpicture}%
    \caption{Two FGF-bisimilar HAFs which are not GF-bisimilar. Relations are drawn top to bottom, so the green area marks the relation $\relP(1,2,3)$}%
    \label{fig:unravel-haf}
\end{figure}

For our new notion of \FGF-unravelling, we make use of the equivalence between bisimulations and games~\cite[Sec. 1.2.1]{Gradel014}.
The $\FGF$-\emph{bisimulation game} is played on two pointed structures $\str{A}, \elemtuplea$ and $\str{B}, \elemtupleb$ by two players, Spoiler and Duplicator.
The game starts by selecting the tuples $\elemtuplea$ and $\elemtupleb$ from each structure.
The game is played in rounds.
In each round, Spoiler first chooses a structure.
The game is symmetric, so let us assume that spoiler chooses the structure $\str{A}$.
Spoiler then selects an infix $\elemtupleafromto{i}{j}$ of the currently selected tuple and a new live tuple $\elemtuplec$ which has $\elemtupleafromto{i}{j}$ as a prefix.
We use the terms \emph{shared elements} for the prefix $\elemtuplecfromto{1}{j-i+1}$ and \emph{unshared elements} for the remaining elements $\elemtuplecfromto{j-i+1+1}{|\elemtuplec|}$.
Duplicator must then find a live tuple $\elemtupled$ in $\str{B}$ with $\elemtuplebfromto{i}{j}$ as prefix such that $\elemtuplec$ and $\elemtupled$ have equal $\FGF$-types.
Note that Spoiler may choose a $j$ that is not maximal, so it is possible that even $a_{j+1} = c_{j-i+1+1}$.
We still regard $c_{j-i+1+1}$ as an unshared element, since Duplicator is allowed to pick a tuple $\elemtupled$ where $b_{j+1} \neq d_{j-i+1+1}$.
The game then continues with the next round, with $\elemtuplec$ and $\elemtupled$ as the new starting tuples.
Spoiler wins the game if Duplicator is unable to find matching tuples.
Duplicator wins if he can always find a matching tuple.
It is easy to see that the possible moves of Spoiler are equivalent to the back-and-forth conditions for $\FGF$-bisimulation, as is also the case for the $\GF$-game~\cite[Sec.\ 3.2]{Gradel014}.
To win, Duplicator must be able to respond to any move that Spoiler makes.
A winning strategy for Duplicator thus corresponds to a $\FGF$-bisimulation between the two structures, and vice-versa.
If we restrict the game to only $\ell$-rounds, where the winning condition for Duplicator is that Spoiler cannot win in the first $\ell$-rounds, then the game is equivalent (in the aforementioned sense) to the existence of a $\ell$-FGF-bisimulation between $\str{A}, \elemtuplea$ and $\str{B}, \elemtupleb$.
We collect these observations in the following lemma:

\begin{lemma}
  In the $\FGF$-game played on structures $\str{A}, \elemtuplea$ and $\str{B}, \elemtupleb$:
  \begin{itemize}
    \item Duplicator has as winning strategy if and only if $\str{A}, \elemtuplea \bisimto_{\FGF} \str{B}, \elemtupleb$,
    \item Duplicator has a winning strategy for $\ell$ rounds if and only if $\str{A}, \elemtuplea \bisimto_{\FGF}^{\ell} \str{B}, \elemtupleb$.
  \end{itemize}
\end{lemma}

\noindent
We next describe the domain of the structures produced by our notion of unravelling.
This domain is based on a sequence of moves in this game.

\noindent \textbf{Domain of the unraveling}
Let $\str{A}, \elemtuplea^{(0)}$ be a pointed structure where $\elemtuplea^{(0)}$ is a standard tuple of elements, labelled with a zero index as it is the starting tuple for the unraveling.
We define a bisimulation sequence as a sequence of moves that Spoiler takes in one of the possible plays of the $\FGF$-bisimulation game involving this structure.
Formally, a \emph{bisimulation sequence} of length $\ell$ is a word in $A^*(\N\N{}A^{*})^{\ell}$, represented by a sequence of the form $\elemtuplea^{(0)}(i^{(1)}, j^{(1)})\elemtuplea^{(1)}\cdots(i^{(\ell)}, j^{(\ell)})\elemtuplea^{(\ell)}$, where each $a^{(k)}$ is a live tuple from $\str{A}$ and $i^{(k)}, j^{(k)}$ are indices for which $\elemtupleafromto{i^{(k)}}{j^{(k)}}^{(k-1)} = \elemtupleafromto{1}{j^{(k)}-i^{(k)}+1}^{k}$.
Intuitively, the set $\Seq{A}$ of all bisimulation sequences for a structure $\str{A}$ collects all possible ways in which Spoiler can explore this structure.
For any bisimulation sequence of length $\ell$, if $\str{B}, \elemtupleb^{(0)}$ is a $\sigma$-structure that is \FGF-bisimilar to $\str{A}, \elemtuplea^{(0)}$, then we can apply \ref{bisim:fforth} $\ell$ times to find tuples $\elemtupleb^{1}, \ldots, \elemtupleb^{\ell}$ for a corresponding bisimulation sequence in $\str{B}$.
These represent the moves of Duplicator in the game.
Below are some examples of bisimulation sequences:
\begin{figure}[H]
  \centering
    \begin{minipage}[t]{0.2\textwidth}
        \raggedleft
        \vspace{0pt}
        \includegraphics[scale=0.5]{res/example-struct-1}
    \end{minipage}
    \hspace{4em}
    \begin{minipage}[t]{0.6\textwidth}
      {%
      \newcommand{\tups}{{\color{tolbrightYellowDarker}\elemtuples}}%
      \newcommand{\tupp}{{\color{tolbrightCyanDarker}\elemtuplep}}%
      \newcommand{\tupt}{{\color{tolbrightGreen}\elemtuplet}}%
      \newcommand{\tupq}{{\color{tolbrightPurple}\elemtupleq}}%
      The picture on the left shows a structure with the relations: $(1,2,3) \in \relS^{\str{A}}$, $(2,3,4) \in \relP^{\str{A}}$, $(3,4,5) \in \relT^{\str{A}}$, $(4,5) \in \relQ^{\str{A}}$.

      \vspace{1ex}
      Let $\tups = (1, 2, 3), \tupp = (2, 3, 4), \tupt = (3, 4, 5), \tupq = (4,5)$.

      \vspace{1ex}
      Some examples of bisimulation sequences in this structure are:
      \begin{itemize}
          \item $\tups(3,3)\tupt$,
          \item $\tups(2,3)\tupp(2,3)\tupt$.
      \end{itemize}

      Bisimulation sequences are not required to use maximal infixes, so the following are also valid bisimulation sequences:
      \begin{itemize}
          \item $\tups(2,2)\tupp$,
          \item $\tups(3,3)\tupt(2,2)\tupq$.
      \end{itemize}
      }
    \end{minipage}
    \caption{Examples of bisimulation sequences.}
\end{figure}

Let $\Seq{\str{A}}$ be the set of all bisimulation sequences for a structure $\str{A}$.
Consider the bisimulation sequences of length zero, which are sequences of just a single tuple $\elemtuplea$ from $\str{A}$.
We pair the sequence~``$\elemtuplea$'' with a natural number, the \emph{counter}, to distinguish the individual elements of $\elemtuplea$.
The domain of the unraveling will thus contain the elements $(\elemtuplea, 1), \ldots, (\elemtuplea, k)$ for the sequence ``$\elemtuplea$'', where $k$ is the length of $\elemtuplea$.
Now, consider a longer bisimulation sequence ``$\cdots \elemtuplea (i,j) \elemtupleb$''.
Recall that this represents a move from tuple $\elemtuplea$ to tuple $\elemtupleb$ in the bisimulation game,
where the first $j-i$ elements of $\elemtupleb$ are shared with $\elemtuplea$.
For example, the pairs $(\cdots \elemtuplea, i)$ and $(\cdots \elemtuplea (i,j) \elemtupleb, 1)$ both describe the $i-th$ component of the tuple $\elemtuplea$.
Hence, for the sequence~``$\cdots\elemtuplea(i,j)\elemtupleb$'', we only add elements with a counter greater than $j-i+1$ to the domain.
These elements correspond to the suffix of unshared elements of $\elemtupleb$.
Formally, the \emph{domain of the unraveling} $\unraveldom{A}$ is a subset of $\Seq{A} \times \mathbb{N}$, with $(\sigma, k) \in \unraveldom{A}$ if:
\begin{itemize}
  \item $\sigma = \elemtuplea$ for $\elemtuplea \sqin A$, then $k \ge 1$ and $k \le |\elemtuplea|$, or
  \item $\sigma = \cdots (i,j) \elemtuplea$, then $k \ge (j-i+1) + 1$ and $k \le |\elemtuplea|$.
\end{itemize}
For an element $e \in \unraveldom{A}$ that can be decomposed as $e = (\rho, k)$, we use the notation $\seq{e} = \rho$ and $\ctr{e} = k$ to denote the sequence and the counter of this element, respectively.
Let $\elemtuplea$ be the last tuple of $\seq{e}$, so $\seq{e} = \cdots \elemtuplea$.
Since the counter refers to elements of $\elemtuplea$, we can define the projection $\pi(e)$ as: $\pi(e) = \elema_{\ctr{e}}$ for $\seq{e} = \cdots\elemtuplea$.
On the domain of the unraveling, the binary relation $\relNext \subseteq \unraveldom{A} \times \unraveldom{A}$ is defined such that $(s, t) \in \relNext$ if either:
\begin{description}
  \item[\desclabel{(addCtr)}{next:addctr}] $\seq{s} = \seq{t}$, $\ctr{t} = \ctr{s} + 1$, or
  \item[\desclabel{(addSeq)}{next:addseq}] $\seq{t} = \seq{s} (i,j) \elemtuplea$ for some $i, j, \elemtuplea$ and $\ctr{s} = j, \ctr{t} = (j - i + 1) + 1$.
\end{description}
The picture below shows an example for this definition.
It depicts a subset of the domain of the unraveling of the structure $\str{E}$ (taken from \cref{fig:unravel-haf}) and the $\relNext$ relation on this domain.

\begin{figure}[H]
  \centering
  \input{res/unravel-domain-ex1.tex}
\end{figure}

\noindent{%
\newcommand{\tupp}{{\color{tolbrightGreenDarker}\elemtuplep}}%
\newcommand{\tupe}{{\color{tolbrightYellowDarker}\elemtuplee}}%
The relation $\relNext$ links elements which represent consecutive components within a tuple of the base structure, but following the structure imposed by the bisimulation sequences, as explained below.
We differentiate two cases.
In the~\ref{next:addctr} case we keep the bisimulation sequence the same and increase the counter by one.
This case is represented by vertical arrows in the above picture.
For example, the elements $(\tupp, 1)$ and $(\tupp, 2)$ represent the elements $1$ and $2$ which are consecutive elements of the tuple $\tupp$, so $((\tupp, 1), (\tupp, 2)) \in \relNext$.
In the~\ref{next:addseq} case, we extend the bisimulation sequence with one more bisimulation move.
This case is represented by arrows that branch sideways in the above picture.
Extending the sequence is only allowed if we start from the element that represents the last (with the highest counter) shared element and end at the first (with the lowest counter) unshared element.
As an example, consider the element $(\tupp, 2)$.
The bisimulation sequence $\tupp(2,2)\tupe$ represents the move from $\tupp$ to $\tupe$, while keeping the second element of $\tupp$ fixed.
Thus, the last shared element is $(\tupp, 2)$ and the first unshared element is $(\tupp(2,2)\tupe, 2)$, so those two elements are in $\relNext$.
Consider now the element $(\tupp(1,1)\tupp, 3)$.
Its bisimulation sequence $\tupp(1,1)\tupp$ is also an extension of the bisimulation sequence of $(\tupp, 2)$.
However, it represents a move from $\tupp$ to $\tupp$ sharing only the first element.
The last (and only) shared element in this move is $(\tupp, 1)$, so there is no edge from $(\tupp, 2)$ to $(\tupp(1,1)\tupp, 3)$.
Similarly, there is no edge from $(\tupp, 1)$ to $(\tupp(1,1)\tupp, 3)$, as $(\tupp(1,1)\tupp, 3)$ is not the first unshared element.

We show that the relation $\relNext$ forms a forest, where the roots are the elements with sequences of length zero and counters equal to 1.
All other elements have an unique parent.
To see why, first observe that if $(s, t) \in \relNext$ because of~\ref{next:addseq}, the element $t$ is the element with the smallest counter among elements of the domain with the same bisimulation sequence.
On the other hand, if $(s, t) \in \relNext$ because of~\ref{next:addctr}, then the element $t$ is never equal to the element with the smallest counter, since $s$ is an element with a smaller counter.
Therefore, the unique parent of elements where the counter is not minimal is obtained by decreasing the counter.
If the counter is minimal and cannot be further decreased, then the unique parent is given by the element with the sequence reduced by one move and counter equal to the index $j$ as specified in the~\ref{next:addseq} case of the definition of $\relNext$.
As the parent in each case either has a shorter sequence or has a sequence of the same length but a lower counter, taking parents repeatedly must end in a root at some point.
So every element is a descendant of some root and has at most one parent, proving that $\relNext$ forms a forest.

Finally, we formalize the property that $\relNext$ links elements that map to consecutive elements in the base structure: if $(s,t) \in \relNext$ and $t$ projects to $a_{k}$ for $k \ge 2$, then $s$ projects to $a_{k-1}$, where $k = \ctr{t}$ and $\elemtuplea$ is the tuple such that $\seq{t} = \cdots \elemtuplea$.
We prove this by case analysis on the two cases of $\relNext$.
The~\ref{next:addctr} case is simple: in this case $\seq{s} = \seq{t}$ and $\ctr{s} = k - 1$, so the property follows directly from the definition of $\pi$.
For the~\ref{next:addseq} case, let $\seq{t} = \seq{s} (i,j) \elemtuplea$ and $\seq{s} = \cdots \elemtupleb$.
Further, in this case $k = (j - i + 1) + 1$ and $\ctr{s} = j$.
By the fact that $\seq{t}$ is a bisimulation sequence, we know that $\elemtupleafromto{1}{j-i+1} = \elemtuplebfromto{i}{j}$.
In particular, it follows that $\pi(s) = b_{j} = a_{j-i+1} = a_{k-1}$, concluding the proof.

\noindent
\textbf{Relations in the unraveling}
A tuple of elements $(e_{1}, \ldots, e_{n})$ is a \emph{next-chain} if consecutive elements are related by $\relNext$, namely $(e_{i}, e_{i+1}) \in \relNext$ for all $i < n$.
If the length $n$ of the next-chain is less than $\ctr{e_{n}}$, then we know by the previous observation that the projection of the chain is $\elemtuplee_{(\ctr{e_{n}}-n+1)\ldots{}\ctr{e_{n}}}$, where $\elemtuples$ is the last tuple of $\seq{e_{n}}$.
We define the tree unraveling such that relations are only realized by tuples which are next-chains.
Additionally, we limit the length of the chain to be less than the counter of the last element of the tuple.
For this, we define the \emph{bound} of a tuple to be equal to the counter of its last element.
Formally, $\mathtt{bound}(\elemtuptupler) = \ctr{r_{|\elemtuptupler|}}$ for any tuple $\elemtuptupler$ from the domain of the unraveling.
Let $\str{A}, \elemtuplea$ be a $\sigma$-structure and $\unraveldom{A}$ be the domain of the unraveling.
Let $\elemtuptuplea = ((\elemtuplea, 1), \ldots, (\elemtuplea, |\elemtuplea|))$.
The \emph{tree unraveling} $\unravel{A}, \elemtuptuplea$ is the tree with root $(\elemtuplea, 1)$ and all descendants according to the relation $\relNext$.
For relations $\relR \in \sigma$, we let $\elemtuptupler \in \relR^{\unravel{A}}$ if and only if:\begin{enumerate}
  \item $\pi[\elemtuptupler] \in \relR^{\str{A}}$,
  \item $\bigwedge_{k=1}^{|\elemtuptupler|-1}{(\elemr_{k},\elemr_{k+1}) \in \relNext}$, and
  \item $|\elemtuptupler| \le \mathtt{bound}(\elemtuptupler)$
\end{enumerate}
The second and third condition restrict live tuples to be next-chains with a length bounded by the counter of the last element of the tuple, as discussed before.

We illustrate the construction with an example.
The picure below shows the tree unraveling $\unravel{E}$ of the structure $\str{E}$ from the previous example with root $(\elemtuplep, 1)$, where again $\elemtuplep = (1,2,3)$ and $\elemtuplee = (2,3)$.
\begin{figure}[H]
  \centering
  \input{res/unravel-ex1.tex}
\end{figure}

\noindent
The example highlights the tree-like property of the tree unraveling.
As relations are required to be next-chains, they must follow along the tree edges specified by the $\relNext$ relation (the black edges in the picture).
We can also see that this structure is $\FGF$-bisimilar to the base structure $\str{E}$.
By the definition of the tree unraveling, elements from the tree unraveling which are related by a relation $\relR$ are mapped by the projection $\pi$ to elements from the base structure which are also related by $\relR$.
\bfside{is this correct, writing $\relR$ here instead of $\relR^{\unravel{E}}$ and $\relR^{\str{E}}$?}
For example, $(\elemtuplep, 2)$ and $(\elemtuptuplep, 3)$ are related by $\relE$ in the unraveling, and so are their projections $2$ and $3$ in the base structure.
This means that $\pi$ preserves $\FGF$-types for live tuples.
It is easy to verify that it also satisfies the back-and-forth conditions for this example, so it is indeed a $\FGF$-bisimulation between $\unravel{E}$ and $\str{E}$.
Note however that not all elements which project to related elements in the base structure are related in the unraveling.
Consider the tuples $\elemtuptuplea = ((\elemtuplep, 1), (\elemtuplep, 2), (\elemtuplep, 3))$ and $\elemtuptupleb = ((\elemtuplep, 1), (\elemtuplep, 2), (\elemtuplep(2,2)\elemtuplee, 2))$.
These tuples have equal projections: $\pi(\elemtuptuplea) = \pi(\elemtuptupleb) = \elemtuplep$.
But $\elemtuptuplea \in \relP^{\unravel{A}}$ while $\elemtuptupleb \notin \relP^{\unravel{A}}$.
This is because $\mathtt{bound}(\elemtuptupleb) = 2$ and $|\elemtuptupleb| = 3$, so the bound for $\elemtuptupleb$ is not large enough.

Intuitively, the unraveling $\unravel{E}$ can be seen as extending the structure $\str{E}$ with additional structure that $\GF$ can distinguish but $\FGF$ cannot.
For example, we saw in \cref{fig:unravel-haf} that there is a $\FGF$-bisimilar structure to $\str{E}$ satsifying the $\GF$ sentence $\exists{x,y}. \relE(x,y) \land \lnot (\exists z. \relP(x,y,z))$, which is not satisfied in $\str{E}$.
Note that this sentence is also satisfied in the unraveling $\unravel{E}$.
In fact, the unraveling contains all such variations which can be distinguished by $\GF$ but not by $\FGF$.
This means that for two structures $\str{A}$ and $\str{B}$ which are $\FGF$-bisimilar, the unraveling for both of them contains all the $\GF$-structure that is possible to add while staying $\FGF$-bisimilar.
Since this only depends on staying $\FGF$-bisimilar but not on the concrete details of the structures $\str{A}$ and $\str{B}$, the resulting unravelings for both structures contain the same $\GF$-structure.
This is exactly what we want for \cref{thm:inf-unraveling-upgrading}, which we can now prove for this notion of unraveling:
\begin{proof}
  \bfbox{write proof}
\end{proof}
