% -*- TeX-engine: xetex -*-
\documentclass{scrartcl}

\usepackage{polyglossia}
\usepackage{fontspec}

\setmainlanguage{english}

\usepackage{blindtext}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[capitalise]{cleveref}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{tabularx}
\usepackage{makecell}
\usepackage{placeins}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{fixme}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{enumitem}

\fxsetup{theme=color,status=draft}

\title{FGF Notes}
\author{Benno Fünfstück}
\date{March 2022}

\newtheorem{theorem}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{example}[theorem]{Example}
\crefname{lemma}{Lemma}{Lemmas}
\crefname{definition}{Definition}{Definitions}
\crefname{theorem}{Theorem}{Theorems}

\newcommand{\last}[1]{\mathtt{last}(#1)}
\newcommand{\struct}[1]{$\mathfrak{#1}$}

\include{tolcolors}

\typeout{CONTENT START NOW}

\begin{document}

\maketitle

\section{Logics}

% exactly as in jair-main
\begin{definition}[Forward (Guarded) Fragment]
Let FF$(n)$ be the smallest fragment of FO satisfying:

\begin{itemize}
    \item an atom $\alpha(\bar{x})$ belongs to FF$(n)$ iff $\alpha$ is equality-free and $\bar{x}$ is an infix of $\bar{x}_{1\ldots{}n}$
    \item FF$(n)$ is closed under boolean connectives $\land, \lor, \neg, \rightarrow, \leftrightarrow$.
    \item If $\phi(\bar{x}_{1\ldots{}n+1}$ is in FF$(n+1)$, then $\exists{x_{n+1}}\phi(\bar{x}_{1\ldots{}n+1})$ and $\forall{x_{n+1}}\phi(\bar{x}_{1\ldots{}n+1})$ are in FF$(n)$.
\end{itemize}

The \emph{forward fragment} FF is the set FF$(0)$.
The \emph{forward guarded fragment} FGF is the \fxfatal*{Allow variable reuse}{intersection of FF with GF}.
\end{definition}

% as in jair-main.pdf
\begin{definition}[Forward type]
A $(\sigma,n)$-forward type is a maximally consistent conjunction of atoms of the form $\pm{}R(\bar{x}_{i\ldots{}i+ar(R)-1}$ for an index $1 \leq i \leq n - ar(R) + 1$.
\end{definition}

We denote by $\mathrm{ftp}_\mathfrak{A}(\bar{a})$ the unique $(\sigma,|\bar{a}|)$-forward type such that $\mathfrak{A} \models \mathrm{ftp}_\mathfrak{A}(\bar{a})$

\section{Back-and-forth conditions / Bisimulations / Games}

% adapted from Otto 2004
\begin{definition}[Connected GF back-and-forth conditions]
Let $\mathfrak{A}$ and $\mathfrak{B}$ be $\sigma$-structures, $\mathcal{Z}, \mathcal{Z'} \subseteq \mathtt{Part}(\mathfrak{A}, \mathfrak{B})$ sets of partial isomorphisms between $\mathfrak{A}$ and $\mathfrak{B}$.

$\mathcal{Z'}$ satisfies the connected GF back-and-forth conditions for $\mathcal{Z}$ if for every $p \in \mathcal{Z}$ the following holds:

\begin{description}
    \item[(gforth)] For any guarded subset $s'$ of $A$ with $s' \cap \mathtt{dom}(p)$ nonempty, there is some $p' \in \mathcal{Z}$ with $\mathtt{dom}(p') = s'$ such that $p$ and $p'$ agree on their common domain.
    \item[(gback)] For any guarded subset $t'$ of $B$ with $t' \cap \mathtt{im}(p)$ nonempty, there is some $p' \in \mathcal{Z}$ with $\mathtt{im}(p') = t'$ such that $p^{-1}$ and $p'^{-1}$ agree on their common domain.
\end{description}
\end{definition}

% adapted from jair-main.pdf
\begin{definition}[Connected FGF back-and-forth conditions]
Let $\mathfrak{A}$ and $\mathfrak{B}$ be $\sigma$-structures, $\mathcal{Z}, \mathcal{Z'} \subseteq \bigcup_{i=0}(A^i \times B^i)$ be mappings such that for any $(\bar{a}, \bar{b}) \in \mathcal{Z} \cup \mathcal{Z'}$ forward types are preserved: $\mathrm{ftp}_\mathfrak{A}(\bar{a}) = \mathrm{ftp}_\mathfrak{B}(\bar{b})$ (\textbf{atomic harmony}).

$\mathcal{Z'}$ satisfies the connected FGF back-and-forth conditions for $\mathcal{Z}$ if for every $(\bar{a}, \bar{b}) \in \mathcal{Z}$ the following conditions hold:

\begin{description}
    \item[(fgforth)] For a nonempty affix $\bar{a}_{i\ldots{}j}$ of $\bar{a}$ and a $\sigma$-live tuple $\bar{c}$ with $|c| \leq k$ in $\mathfrak{A}$ such that $\bar{a}_{i\ldots{}j} = \bar{c}_{1\ldots{}j-i+1}$ there is a tuple $\bar{d}$ with $\bar{b}_{i\ldots{}j} = \bar{d}_{1\ldots{}j-i+1}$ and $(\bar{c}, \bar{d}) \in \mathcal{Z'}$
    \item[(fgback)] For a nonempty affix $\bar{b}_{i\ldots{}j}$ of $\bar{b}$ and a $\sigma$-live tuple $\bar{d}$ with $|d| \leq k$ in $\mathfrak{B}$ such that $\bar{b}_{i\ldots{}j} = \bar{d}_{1\ldots{}j-i+1}$ there is a tuple $\bar{c}$ with $\bar{a}_{i\ldots{}j} = \bar{c}_{1\ldots{}j-i+1}$ and $(\bar{c}, \bar{d}) \in \mathcal{Z'}$
\end{description}
\end{definition}

\begin{definition}[Connected Bisimulation]
A set $\mathcal{Z}$ is a connected GF or FGF bisimulation between pointed $\sigma$-structures $\mathfrak{A}, \bar{a}$ and $\mathfrak{B}, \bar{b}$ if it satisfies the connected GF respective FGF back-and-forth conditions for itself and $(\bar{a}, \bar{b}) \in \mathcal{Z}$.
\end{definition}

We write $\mathfrak{A}, \bar{a} \sim_{\textrm{GF}} \mathfrak{B}, \bar{b}$ or $\mathfrak{A}, \bar{a} \sim_{\textrm{FGF}} \mathfrak{B}, \bar{b}$ if there exists a connected GF respective FGF bisimulation between pointed $\sigma$-structures $\mathfrak{A}, \bar{a}$ and $\mathfrak{B}, \bar{b}$.

\begin{definition}[k-Level Bisimulation]
A k-level bisimulation is a sequence of sets $\mathcal{Z}_0, \ldots, \mathcal{Z}_k$ such that each $\mathcal{Z}_{i - 1}$ for $0 < i \le k$ satisfies the associated back-and-forth conditions for $\mathcal{Z}_i$.
\end{definition}

We write $\mathfrak{A}, \bar{a} \sim_{\textrm{GF}, k} \mathfrak{B}, \bar{b}$ or $\mathfrak{A}, \bar{a} \sim_{\textrm{FGF}, k} \mathfrak{B}, \bar{b}$ if there exists a k-level connected GF respective FGF bisimulation between pointed $\sigma$-structures $\mathfrak{A}, \bar{a}$ and $\mathfrak{B}, \bar{b}$.

\begin{definition}[Global Bisimulation]
A global bisimulation between $\sigma$-structures $\mathfrak{A}$ and $\mathfrak{B}$ is a set $\mathcal{Z}$ such that for any guarded tuple $\bar{a} \in \mathfrak{A}$ there is a guarded tuple $\bar{b} \in \mathfrak{B}$ such that $(\bar{a}, \bar{b}) \in \mathcal{Z}$ and vice versa.
\end{definition}

\pagebreak

\section{Tree unraveling}

\subsection{Bisimulation path}

\begin{definition}[Connected Forward Bisimulation Path]\label{def:bisim-path}
  A \emph{connected forward bisimulation path} of \emph{length} $n$ with \emph{start} $\bar{s}_{0}$ for a structure \struct{A} is a sequence $\rho = \bar{s}_{0}(i_{1}, j_{1})\bar{s}_{1}\cdots{}(i_{n}, j_{n})\bar{s}_{n}$ where:
  \begin{itemize}
    \item each $\bar{s}_{k}$ for $0 \le k \le n$ is a guarded tuple from \struct{A}
    \item each $(i_{k}, j_{k})$ for $1 \le k \le n$ are a pair of indices into $\bar{s}_{k-1}$, such that $\bar{s}_{k-1,i\ldots{}j} = \bar{s}_{k,1\ldots{j-i+1}}$
  \end{itemize}
\end{definition}

\begin{definition}[Strict Connected Forward Bisimulation Path]
  A bisimulation path $\rho = \bar{s}_{0}(i_{1}, j_{1})\bar{s}_{1}\cdots{}(i_{n}, j_{n})\bar{s}_{n}$ is called strict iff:

  \begin{enumerate}
    \item \textbf{tail is not empty}: $j_{k}-i_{k}+1 < |s_{k}|$ for $1 \le k \le n$, and
    \item \textbf{previous tail is used}: $j_{k} > j_{k-1}-i_{k-1} + 1$ for $2 \le k \le n$
  \end{enumerate}
\end{definition}

\pagebreak

\begin{example}[Bisimulation paths]\leavevmode\\*[1em]
  {%
    \newcommand{\tups}{{\color{tolbrightYellowDarker}\bar{s}}}%
    \newcommand{\tupp}{{\color{tolbrightCyanDarker}\bar{p}}}%
    \newcommand{\tupt}{{\color{tolbrightGreen}\bar{t}}}%
    \newcommand{\tupq}{{\color{tolbrightPurple}\bar{q}}}%
  \begin{minipage}[t]{0.6\textwidth}
    Bisimulation paths in \cref{fig:fgf-struct-a}:
    \begin{enumerate}
      \item $\rho_{1} = \tups$
      \item $\rho_{2} = \tups(2,2)\tupp$
      \item $\rho_{3} = \tups(2,2)\tupp(2,2)\tupt$
      \item $\rho_{4} = \tups(2,2)\tupp(2,2)\tupt(2,2)\tupq$
      \item $\rho_{5} = \tups(2,2)\tupp(2,2)\tupt(2,3)\tupq$, not strict (1)
      \item $\rho_{7} = \tups(2,2)\tupp(2,3)\tupt$
      \item $\rho_{7} = \tups(2,2)\tupp(2,3)\tupt(2,2)\tupq$
      \item $\rho_{8} = \tups(2,2)\tupp(2,3)\tupt(2,3)\tupq$, not strict (1)
      \item $\rho_{9} = \tups(2,2)\tupp(3,3)\tupq$
      \item $\rho_{10} = \tups(2,3)\tupp(2,2)\tupt$, not strict (2)
      \item $\rho_{11} = \tups(2,3)\tupp(2,2)\tupt(2,2)\tupq$, not strict (2)
      \item $\rho_{12} = \tups(2,3)\tupp(2,2)\tupt(2,3)\tupq$, not strict (1)
      \item $\rho_{13} = \tups(2,3)\tupp(2,3)\tupt$
      \item $\rho_{14} = \tups(2,3)\tupp(2,3)\tupt(2,2)\tupq$
      \item $\rho_{15} = \tups(2,3)\tupp(2,3)\tupt(2,3)\tupq$, not strict (1)
      \item $\rho_{16} = \tups(2,3)\tupp(3,3)\tupq$
      \item $\rho_{17} = \tups(3,3)\tupt$
      \item $\rho_{18} = \tups(3,3)\tupt(2,2)\tupq$
      \item $\rho_{19} = \tups(3,3)\tupt(2,3)\tupq$, not strict (1)
    \end{enumerate}
  \end{minipage}\hfill
  \begin{minipage}[t]{0.35\textwidth}
    \vspace{0pt}
    \includegraphics[width=0.9\textwidth]{svg/fgf-unravel.svg/example-struct-1}
    \captionof{figure}{Example structure \struct{A}}
    \label{fig:fgf-struct-a} \leavevmode\\[-0.5em]
    \raggedright
    $ \tups = (1,2,3)$, $\tupp = (2,3,4)$, $\tupt = (3,4,5)$, $\tupq = (4,5)$. \\

    \begin{enumerate}[label=(\arabic*)]
      \item not strict because tail in step from $\tupt$ to $\tupq$ is empty
      \item not strict because step from $\tupp$ to $\tupt$ does not use previous tail
    \end{enumerate}
  \end{minipage}
  }
\end{example}

\end{document}
