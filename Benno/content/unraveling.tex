%!TEX root = ../main.tex
\chapter{Tree Unravelings}\label{chap:unraveling}
A fundamental property of modal logics is that their models are tree-like, where we can think of tree-like models as models that are similar to trees as known from graph theory (we give an exact definition later).
We show in this chapter that a special form of tree models provide a logically tractable~\cite{otto2013} class of models for $\FGF$.
In this class of models, the weak form of $\bisimto_{\FGF}$-equivalence coincides with the stronger notion of $\bisimto_{\GF}$-equivalence.
To obtain such models, we introduce a new notion of tree unraveling for $\FGF$, which takes an arbitrary model and constructs a structure which is bisimilar to this model but additionally is tree-like.
An explanation for why we need a new unraveling is provided in the first section of this chapter, where we give a short review of existing notions of unraveling for $\FGF$ and $\GF$.
In essence, the tree model obtained via our new method of unraveling provides a representative for a $\bisimto_{\FGF}$ equivalence class, which is unique up to $\bisimto_{\GF}$-equivalence.
This is the first step towards the construction of finite companions as required for \cref{thm:main-technical-thm}.
The following theorem highlights the main property of our new notion of unraveling for $\FGF$, developed in this chapter:
\begin{restatable*}{theorem}{thminfupgrading}\label{thm:inf-bisim-upgrading}
  For unravelings $(\unravel{A}, \elemtuptuplea)$ and $(\unravel{B}, \elemtuptupleb)$  of two structures $(\str{A}, \elemtuplea)$ and $(\str{B}, \elemtupleb)$, if $(\unravel{A}, \elemtuptuplea) \bisimto_{\FGF} (\unravel{B}, \elemtuptupleb)$ then $(\unravel{A}, \elemtuptuplea) \bisimto_{\GF} (\unravel{B}, \elemtuptupleb)$.
\end{restatable*}%

For structures $\str{A}$ with a distinguished binary predicate $\relNext^{\str{A}}$, we employ tailored terminology from graph theory.
For instance, whenever $(\eleme_1, \eleme_2) \in \relNext^{\str{A}}$, we call the element $\eleme_2$ a \emph{child} of $\eleme_1$. Respectively, we call $\eleme_1$ a \emph{parent} of $\eleme_2$.
A \emph{root} is an element without parents.
The set of \emph{descendants} of an element $\eleme$ is the smallest set containing $\eleme$ that is closed under taking children (\ie{} if an element is in the set then so are its children).
We call a structure $\str{A}$ a \emph{forest} if every element has at most one parent and is a descendant of some root.
A forest is a \emph{tree} if it has exactly one root.
We say that a model is a \emph{forest model} (or \emph{tree model}) if it has a domain which is a forest (or tree).

\section{Existing notions of unraveling for $\FGF$ and $\GF$}\label{sec:existing-unravelings}
In this section, we review two existing notions of tree unraveling, one for $\FGF$ and one for $\GF$.
This is helpful to understand the motivation for our new unraveling.
Readers who are only interested in the new unraveling may safely skip this section.

We focus on structures $\str{A}$ without distinguished elements here, to simplify the definitions.
However, extending these definitions to pointed structures $(\str{A}, \elemtuplea)$ is not difficult.
We start with the definitions, and show some examples afterwards.
We begin with the unraveling for $\GF$, as described by Andr√©ka et al.\cite[Sec 4.3, p. 247]{AndrekaNB98}.
\begin{definition}[$\GF$-unraveling]
  The domain of the \emph{$\GF$-unraveling} $\gfunravel{A}$ of a structure $\str{A}$ consists of pairs $(\rho, a)$ where $\rho$ is a finite sequence of guarded sets and $a \in A$ is an element which is ``new'' in $\rho$: it occurs in the last set of $\rho$, but not in the one before that.
  Every relation $\relR \in \Sigma$ is interpreted in $\gfunravel{A}$ as follows: for a tuple $\gfunraveltup{a} = ((\rho_{1}, a_{1}), \ldots, (\rho_{n}, a_{n}))$ with $n \in N$, we let $\gfunraveltup{a} \in \relR^{\gfunravel{A}}$ if:
  \begin{enumerate}
    \item $(a_{1}, \ldots, a_{n}) \in \relR^{\str{A}}$, \ie{} the ``new'' elements of each pair are related by $\relR$ in the base structure,
    \item there is a maximal sequence $p_{j}$: for some $j \in [1,n]$, every $\rho_{i}$ for $i \in [1,n]$ is a prefix of $\rho_{j}$,
    \item the new elements $a_{i}$ remain present in each guarded set from $\rho_{i}$ to the end of $\rho_{j}$.
  \end{enumerate}
\end{definition}
As expected, the $\GF$-unraveling $\gfunravel{A}$ is $\GF$-bisimilar to the original structure $\str{A}$~\cite[Proposition 4.3.1]{AndrekaNB98}.

For comparison, we now present the \emph{HAF-unraveling}, an unraveling for $\FGF$ introduced by Bednarczyk~\cite[Sec 3.3]{Bednarczyk21}.
Our presentation here is based on a later version of this unraveling, the \emph{HAH-unraveling}~\cite[Appendix C.4, Definition 20]{BednarczykJ22}, which is the same as the HAF-unraveling for signatures without constants.
\begin{definition}[HAH-unraveling]
  The domain of the \emph{HAH-unraveling} $\hatunravel{A}$ of a structure $\str{A}$ contains all finite sequences $\rho = a_{1}\cdots{}a_{n}$ of elements from $A$ for all $n \in \N^{+}$, with the following additional property:
  For every $i \in [1,n-1]$, the elements $a_{i}, a_{i+1}$ appear consecutively in some relation, \ie{} there are tuples $\elemtuplee, \elemtuplef \sqin A$  of elements from $\str{A}$ such that, for some relation $\relR \in \Sigma$:
  \begin{equation*}
    \elemtuplee{}\,a_{i}\,a_{i+1}\,\elemtuplef{} \in \relR^{\str{A}}.
  \end{equation*}
  For each sequence $\rho$ in the domain, we define $\mathrm{last}(\rho) = a$ where $a$ is the last element of $\rho$, \ie{} $\rho = \cdots a$.
  Every relation $\relR \in \Sigma$ is interpreted in $\hatunravel{A}$ as follows: for a tuple $\hatunraveltup{a} = (\rho_{1}, \ldots, \rho_{n})$ with $n \in \N$, we let $\hatunraveltup{a} \in \relR^{\hatunravel{A}}$ if:
  \begin{enumerate}
    \item $(\mathrm{last}(\rho_{1}), \ldots, \mathrm{last}(\rho_{n})) \in \relR^{\str{A}}$, \ie{} the last elements of each sequence are related by $\relR$ in the base structure, and
    \item there are elements $e_{2}, \ldots, e_{n} \in A$ such that $\rho_{i} = \rho_{1}e_{1}\cdots{}e_{i}$ for all $i \in [2,n]$.
  \end{enumerate}
\end{definition}
Similarly to the case for $\GF$, the HAH-unraveling $\hatunravel{A}$ is $\FGF$-bisimilar to the original structure $\str{A}$~\cite[Appendix C.4, Lemma 23]{BednarczykJ22}.

\begin{example}
  \newlength\figindent\setlength\figindent{7em}%
  \newlength\figdist\setlength\figdist{2em}%
  To demonstrate the above definitions, consider the following structure $\str{A}$:\\[1ex]
  \begin{minipage}{\figindent}
    \raggedleft
    \Huge{$\str{A}$}
  \end{minipage}
  \hspace{\figdist}
  \input{res/ex-other-unravel-struct.tex}\\

  \noindent
  We first draw unravelings and explain some details.
  For the $\GF$-unraveling, the guarded sets of $\str{A}$ are:
  \begin{equation*}
    s_{1} = \{1,2\}\quad
    s_{2} = \{1,3\}\quad
    s_{3} = \{1,2,3\}\quad
    s_{4} = \{2,3,4\}\quad
    s_{5} = \{2,3\}\quad
    s_{6} = \{3,4\}\quad
  \end{equation*}
  Since we can form elements of the $\GF$-unraveling from any finite sequence of those sets, the $\GF$-unraveling is infinite.
  The following figure shows a substructure of the full unraveling.
  For better readability, we use $\rho / a$ to denote the pair $(\rho, a)$ for a sequence $\rho$ and an element $a \in A$.\\[2ex]
  \begin{minipage}{\figindent}
    \raggedleft
    part of \Huge{$\gfunravel{A}$}
  \end{minipage}
  \hspace{\figdist}
  \input{res/ex-other-unravel-gf.tex}\\[1ex]

  \noindent
  Next, we construct the HAH-unraveling $\hatunravel{A}$. First, let us draw the graph of elements which appear consecutively in relations, which gives the following picture:\\[1ex]
  \begin{minipage}{\figindent}
    \mbox{}
  \end{minipage}
  \hspace{\figdist}
  \input{res/ex-other-unravel-gaifman.tex}\\[1ex]
  The elements of the HAH-unraveling correspond to paths in this graph.
  The following picture shows a part of the unraveling, focusing on paths starting from the element $1$:\\[1ex]
  \begin{minipage}{\figindent}
    \raggedleft
    part of \Huge{$\hatunravel{A}$}
  \end{minipage}
  \hspace{\figdist}
  \input{res/ex-other-unravel-forward.tex}\\[2ex]
  The black, dashed edges show the underlying tree structure of this unraveling.

  Observe how in the HAH-unraveling, all the relations are perfectly aligned to edges of the tree, \ie{} the tuples in relations are paths in the underlying tree.
  For example, $(1, 123) \notin \textcolor{tolhighcontrastRed}{\relS}^{\hatunravel{A}}$.
  This is because of condition (2) in the definition of the HAF-unraveling.
  The same is not true in the $\GF$-unraveling, since the $\GF$-unraveling does not fix the order of elements in tuples of relations.
  An example are the elements $s_{1}s_{2}s_{6}s_{4}/2$ and $s_{1}s_{5}/3)$ which are related by $\textcolor{tolhighcontrastRed}{\relS}^{\hatunravel{A}}$, even though the sequence in the first element is longer than the sequence in the second.
  The $\GF$-unraveling allows this, since condition (2) only asserts the existence of some maximal sequence $\sigma_{j}$ among the elements of the tuple, which does not need to come from the last element.

  To see the effect of condition (3) for relations in the $\GF$-unraveling, consider the relation $\textcolor{tolhighcontrastBlue}{\relP}^{\gfunravel{A}}$ and the tuple of elements $s_{1}/1, s_{1}/2, s_{1}s_{4}/3$.
  For this tuple, $\sigma_{3} = s_{1}s_{4}$ is a maximal sequence and the elements $(1,2,3)$ are in the relation $\textcolor{tolhighcontrastBlue}{\relP}^{\str{A}}$ in the base structure.
  Hence, the first two conditions are satisfied.
  However, the element $1$ is not in $s_{4}$, so it is not present in all guarded sets from $s_{1}$ to the maximal sequence $s_{1}s_{4}$, violating condition (3).
  Therefore, the elements $s_{1}/1, s_{1}/2, s_{1}s_{4}/3$ are not in $\textcolor{tolhighcontrastBlue}{\relP}^{\hatunravel{A}}$.

  One interesting detail is that the HAH-unraveling preserves some first-order properties which are not preserved by the $\GF$-unraveling, and vice-versa.
  For the first direction, take the $\FO$-formula $\varphi := \forall{x_{1}x_{2}x_{3}}\; ((\textcolor{tolhighcontrastRed}{\relS}(x_{1},x_{2}) \land \textcolor{tolhighcontrastRed}{\relS}(x_{2},x_{3})) \to \textcolor{tolhighcontrastBlue}{\relP}(x_{1}, x_{2}, x_{3}))$.
  This formula is true in $\str{A}$ and $\hatunravel{A}$, but not in $\gfunravel{A}$.
  For the converse, take the $\GF$-formula $\psi = \exists{x_{1}x_{2}x_{3}}\; (\textcolor{tolhighcontrastBlue}{\relP}(x_{1},x_{2},x_{3}) \land \exists{x_{4}}\textcolor{tolhighcontrastBlue}{\relP}(x_{4},x_{3},x_{2}))$.
  This formula is true in $\str{A}$ and $\gfunravel{A}$, but not in $\hatunravel{A}$.
\end{example}

In both definitions, the domain of the unraveling is constructed from sequences.
In the guarded case, these sequences consist of guarded sets, with an additional distinguished element from the last guarded set in the sequence.
In the case for $\FGF$, because of the forwardness, we do not need the power to arbitrary chose a distinguished element among a set of elements.
Instead, it is sufficient to consider sequences consisting of single elements only, with the distinguished element fixed to the last element of the sequence.
This difference also shows in condition (2) of the above definitions.
In the guarded case, condition (2) does not impose an ordering on the elements of tuples, it simply asserts the existence of some maximial sequence $p_{j}$ among all the available sequences $p_{i}$.
In contrast, condition (2) in the forward case says that the last sequence is maximal and contains all the other sequences as prefixes.
In fact, it is even more strict: for any live tuple $\hatunraveltup{a}$ from the HAT-unraveling, the sequence $a_{i}$ is not just required to be a prefix of the sequence $a_{i+1}$, but instead it is \emph{exactly} the sequence obtained by dropping the last element of the sequence $a_{i+1}$.

We now show that the notion of HAH-unraveling does not satisfy \cref{thm:inf-bisim-upgrading}.
Consider the following two structures, with the relational symbols $\textcolor{tolhighcontrastYellow}{\relE}$ of arity two and $\textcolor{tolhighcontrastBlue}{\relP}$ of arity 3:
\begin{center}
\input{res/hat-not-gf-structs}
\end{center}
These structures are $\FGF$-bisimilar, with a bisimulation that associates $1$ with $a$, $2$ with $b$ and $3$ with $c$ and $d$ (and similar for tuples of elements).
This means that their HAH-unravelings are also $\FGF$-bisimilar, since they are bisimilar to the original structure and $\bisimto_{\FGF}$ is transitive.
The unravelings are shown in the following picture:
\begin{figure}[H]
\begin{center}
\input{res/hat-not-gf-unravel}
\caption{$\FGF$-bisimilar HAH-unravelings which are not $\GF$-bisimilar}%
\label{fig:hat-not-gf-unravel}
\end{center}
\end{figure}

\noindent
However, $\hatunravel{A}$ and $\hatunravel{B}$ can be distinguished by a $\GF$ sentence $\exists{x_{2}x_{3}}\,( \textcolor{tolhighcontrastYellow}{\relE}(x_{2},x_{3}) \land \lnot (\exists x_{1}. \textcolor{tolhighcontrastBlue}{\relP}(x_{1},x_{2},x_{3})))$.
Hence, the unravelings are not $\GF$-bisimilar.
This shows that \cref{thm:inf-unraveling-upgrading} fails for the HAH-unraveling, even in the finite case.
To fix this, we develop a new unraveling for $\FGF$.

\section{A new unraveling for $\FGF$}
Our new notion of unraveling employs concepts from the $\FGF$-game as introduced in \cref{sec:biseqs-and-bipoints}.
The \emph{domain of the unraveling} for a structure $\str{A}$, denoted by $\unraveldom{A}$, is simply the set of all bipoints of the structure $\str{A}$.
We first introduce a relation $\relNext$ and show that it defines a forest on this set and then specify how to interpret relations in this domain.

\begin{definition}[$\relNext$ relation]
On the domain of the unraveling, the binary relation $\relNext \subseteq \unraveldom{A} \times \unraveldom{A}$ is defined such that $(s, t) \in \relNext$ if either:
\begin{description}
  \item[\desclabel{(addCtr)}{next:addctr}] $s = (\sigma, k)$ and $t = (\sigma, k + 1)$ for some $\sigma \in \Seq{A}$ and $k \in \N$, or
  \item[\desclabel{(addSeq)}{next:addseq}] $s = (\sigma, j)$ and $t = (\sigma(i,j)\elemtuplea, (j-i+1) + 1)$ for some $\sigma \in \Seq{A}$, $\elemtuplea \sqin A$ and $i,j \in \N$.
\end{description}
\end{definition}
\begin{example}\label{ex:unravel-dom}
  The following picture shows a subset of the domain of the unraveling of the structure $\str{E}$ and the $\relNext$ relation on this domain.

\begin{figure}[H]
  \centering
  \input{res/unravel-domain-ex1.tex}
\end{figure}

\noindent{%
\newcommand{\tupp}{{\color{tolbrightGreenDarker}\elemtuplep}}%
\newcommand{\tupe}{{\color{tolbrightYellowDarker}\elemtuplee}}%
The relation $\relNext$ links elements which represent consecutive components within a tuple of the base structure, but following the structure imposed by the biseqs, as explained below.
There are two cases.
In the~\ref{next:addctr} case we keep the biseq the same and increase the counter by one.
This case is represented by vertical arrows in the above picture.
For example, the elements $(\tupp, 1)$ and $(\tupp, 2)$ represent the elements $1$ and~$2$ which are consecutive elements of the tuple $\tupp$, so $((\tupp, 1), (\tupp, 2)) \in \relNext$.
In the~\ref{next:addseq} case, we extend the biseq with one more bisimulation move.
This case is represented by arrows that branch sideways in the above picture.
If the biseq is extended during a transation along a $\relNext$ edge, then the start of the edge is the last (with the highest counter) shared element and the end of the edge is the first (with the lowest counter) unshared element for the new biseq.
As an example, consider the element $(\tupp, 2)$.
The biseq $\tupp(2,2)\tupe$ represents the move from $\tupp$ to $\tupe$, while keeping the second element of $\tupp$ fixed.
Thus, the last shared element is $(\tupp, 2)$ and the first unshared element is $(\tupp(2,2)\tupe, 2)$, so those two elements are in $\relNext$.
Now consider the element $(\tupp(1,1)\tupp, 3)$.
Its biseq $\tupp(1,1)\tupp$ is also an extension of the biseq of $(\tupp, 2)$.
However, it represents a move from $\tupp$ to $\tupp$ sharing only the first element.
The last (and only) shared element in this move is $(\tupp, 1)$, so there is no edge from $(\tupp, 2)$ to $(\tupp(1,1)\tupp, 3)$.
Similarly, there is no edge from $(\tupp, 1)$ to $(\tupp(1,1)\tupp, 3)$, as $(\tupp(1,1)\tupp, 3)$ is not the first unshared element.
}
\end{example}
\begin{lemma}
  For any structure $\str{A}$, the domain of the unraveling $\unraveldom{A}$ together with the relation $\relNext$ is a forest. The roots are the elements composed of a 0-biseq and a counter equal to 1.
\end{lemma}
\begin{proofsketch}
  The counter of an element $t \in \unraveldom{A}$ is \emph{minimal} if the counter is the smallest among elements of the domain with the same biseq as $t$.
  The key observation now is that if $(s,t) \in \relNext$ because of case~\ref{next:addseq}, then the counter of $t$ is minimal, while if $(s,t) \in \relNext$ because of case~\ref{next:addctr}, then the counter of $t$ cannot be minimal (since $s$ is witness that there are elements with a smaller counter).
  Take an element $t \in \unraveldom{A}$ with $(s, t) \in \relNext$ for some element $s \in \unraveldom{A}$.
  If the counter is not minimal, then the unique parent $s$ is element obtained by decreasing the counter by one.
  If the counter is minimal and cannot be further decreased, then the unique parent $s$ is the element with the biseq reduced by one move and counter equal to the index $j$ as specified in the~\ref{next:addseq} case of the definition of $\relNext$.
  We observe that the parent of an element either has a biseq with a decreased level or it has a biseq with the same level but a decreased counter.
  Thus, taking parents repeatedly must end in a root at some point.
  Therefore every element is a descendant of some root and has at most one parent, proving that $\relNext$ forms a forest.
  The only elements without a parent are those composed of a 0-biseq and a minimal counter.
  Since $(\sigma, 1) \in \unraveldom{A}$ for any 0-biseq $\sigma \in \Seq{A}$, the roots are exactly the elements composed of a 0-biseq and a counter equal to 1.
\end{proofsketch}

The above example highlights an important property of $\relNext$.
If we have elements $s,t \in \unraveldom{A}$ which are linked by $\relNext$ then they appear as consecutive elements in a tuple of a relation in the base structure.
In fact, they appear as consecutive elements in the tuple equal to the last tuple of the biseq of t (\ie $\Pi(\seq{t})$), as stated in the following lemma:
\begin{lemma}
For elements $s, t \in \unraveldom{A}$ with $\ctr{t} \ge 2$ and $(s,t) \in \relNext$, if $\elemtuplea \sqin \unraveldom{A}$ is the tuple such that $\seq{t} = \cdots \elemtuplea$, then $\pi(s) = a_{k-1}$ and $\pi(t) = a_{k}$ for $k = \ctr{t}$.
\end{lemma}
\begin{proofsketch}
  Let $\seq{s} = \cdots \elemtupleb$.
  Since $(s,t) \in \relNext$, the biseq $\seq{t}$ extends $\seq{s}$.
  Thus, $\elemtupleb$ and $\elemtuplea$ must an share an infix (by definition of biseqs).
  The definition of $\relNext$ restricts the counters $\ctr{s}$ and $\ctr{t}$ such that the equality $b_{\ctr{s}} = a_{\ctr{t}-1}$ holds, implying the property of the lemma.
\end{proofsketch}
\begin{proof}
  Note that $\pi(t) = a_{\ctr{t}} = a_{k}$ by definition of the projection $\pi$.
  We prove that $\pi(s) = a_{k-1}$ by case analysis on the two cases of $\relNext$.
  The~\ref{next:addctr} case is simple: in this case $\seq{s} = \seq{t}$ and $\ctr{s} = k - 1$, so the property follows directly from the definition of $\pi$.
  For the~\ref{next:addseq} case, let $\seq{t} = \seq{s} (i,j) \elemtuplea$ and $\seq{s} = \cdots \elemtupleb$.
  Further, in this case $k = (j - i + 1) + 1$ and $\ctr{s} = j$.
  By the fact that $\seq{t}$ is a biseq, we know that $\elemtupleafromto{1}{j-i+1} = \elemtuplebfromto{i}{j}$.
  In particular, it follows that $\pi(s) = b_{j} = a_{j-i+1} = a_{k-1}$, concluding the proof.
\end{proof}

\noindent
We now give a formal definition of the tree unraveling for a structure, followed by examples to explain this definition.
Let $\str{A}, \elemtuplea$ be a structure, $\unraveldom{A}$ be the domain of the unraveling and $\elemtuplee$ a tuple of elements $(e_{1}, \ldots, e_{n}) \sqin \unraveldom{A}$..
The tuple $\elemtuplee$ is a \emph{next-chain} if consecutive elements are related by $\relNext$, namely $(e_{i}, e_{i+1}) \in \relNext$ for all $i < n$.
If we think of $\relNext$ as representing edges in a tree, then next-chains are precisely the paths in this tree.
We define the \emph{bound} of $\elemtuptuplee$ (denoted by $\bound{\elemtuptuplee}$) as the counter of its last element, expressed formally as $\bound{\elemtuptuplee} = \ctr{e_{|\elemtuptuplee|}} = \ctr{e_{n}}$.
\begin{definition}[Tree Unraveling]
The \emph{tree unraveling} $\unravel{A}, \elemtuptuplea$ of $\str{A}, \elemtuplea$ is the structure with the forest $\unraveldom{A}$ as domain and $\elemtuptuplea = ((\elemtuplea, 1), \ldots, (\elemtuplea, |\elemtuplea|))$.
For each relation $\relR \in \Sigma$, a tuple $\elemtuptupler \in \relR^{\unravel{A}}$ if and only if:
\begin{enumerate}
  \item $\pi[\elemtuptupler] \in \relR^{\str{A}}$,
  \item $\bigwedge_{k=1}^{|\elemtuptupler|-1}{(\elemr_{k},\elemr_{k+1}) \in \relNext}$, and
  \item $|\elemtuptupler| \le \bound{\elemtuptupler}$
\end{enumerate}
\end{definition}
This means that in the unraveling, the members of a relation $\relR^{\unravel{A}}$ are those next-chains (condition 2) which project to members of the relation in the base structure $\relR^{\str{A}}$ (condition 1) and have a length bounded by the counter of the last element in the chain (condition 3).
This definition is best illustrated with an example, which also helps to understand condition 3:

\begin{example}
The picture below shows a subtree of the tree unraveling $\unravel{E}$ of the structure $\str{E}$ from the previous example (\cref{ex:unravel-dom}) with root $(\elemtuplep, 1)$, where again $\elemtuplep = (1,2,3)$ and $\elemtuplee = (2,3)$.
\begin{figure}[H]
  \centering
  \input{res/unravel-ex1.tex}
\end{figure}

\noindent
The example highlights the tree-like property of the tree unraveling.
As tuples in a relation are next-chains, they follow along the tree edges specified by the $\relNext$ relation (the black edges in the picture).
By the definition of the tree unraveling, elements from the tree unraveling which are related by a relation $\relR$ are mapped by the projection $\pi$ to elements from the base structure which are also related by $\relR$.
For example, $(\elemtuplep, 2)$ and $(\elemtuptuplep, 3)$ are related by $\relE$ in the unraveling, and so are their projections $2$ and $3$ in the base structure.
This means that $\pi$ preserves $\FGF$-types for live tuples.
It is easy to verify that it also satisfies the back-and-forth conditions for this example, so there exists an $\FGF$-bisimulation between $\unravel{E}$ and $\str{E}$.
Observe how condition 3 of the definition applies in this example.
Consider the tuples $\elemtuptuplea = ((\elemtuplep, 1), (\elemtuplep, 2), (\elemtuplep, 3))$ and $\elemtuptupleb = ((\elemtuplep, 1), (\elemtuplep, 2), (\elemtuplep(2,2)\elemtuplee, 2))$.
These tuples have equal projections: $\pi(\elemtuptuplea) = \pi(\elemtuptupleb) = \elemtuplep$ and are next-chains.
But $\elemtuptuplea \in \relP^{\unravel{A}}$ while $\elemtuptupleb \notin \relP^{\unravel{A}}$.
This is because $\bound{\elemtuptupleb} = 2$ and $|\elemtuptupleb| = 3$, so the bound for $\elemtuptupleb$ is not large enough.
\end{example}

Intuitively, the unraveling $\unravel{E}$ can be seen as extending the structure $\str{E}$ with additional structure that $\GF$ can distinguish but $\FGF$ cannot.
For example, we saw in \cref{fig:hat-not-gf-unravel} that there is an $\FGF$-bisimilar structure to $\str{E}$ satisfying the $\GF$ sentence $\exists{x,y}. \relE(x,y) \land \lnot (\exists z. \relP(x,y,z))$, which is not satisfied in $\str{E}$.
But the unraveling $\unravel{E}$ has added the necessary extra elements so that this sentence is satisfied in the unraveling.
Observe that the unraveling mainly depends on the behavior of the original structure in the $\FGF$-game, not on concrete details of its representation.
To make this claim precise, we show that if we take two structures which behave the same in the $\FGF$-game (\ie{} they are $\FGF$-bisimilar), this new notion of unraveling yields structures which are indistinguishable by $\GF$.
Hence, the unraveling of a structure is a characterization of its behavior in the $\FGF$-game, up to $\GF$-equivalence. The following theorem makes this claim concrete.
\begin{restatable}{theorem}{thminfunraveling}\label{thm:inf-unraveling-upgrading}
  Let $\str{A}, \elemtuplea \bisimto_{\FGF} \str{B}, \elemtupleb$ for two pointed structures.
  Then there are forest models $\unravel{A}, \elemtuptuplea$ and $\unravel{B}, \elemtuptupleb$ which are both:
  \begin{itemize}
    \item $\FGF$-similar to the original structures: $\unravel{A}, \elemtuptuplea \bisimto_{\FGF} \str{A}, \elemtuplea$ and $\unravel{B}, \elemtuptupleb \bisimto_{\FGF} \str{B}, \elemtupleb$
    \item $\GF$-bisimilar: $\unravel{A}, \elemtuptuplea \bisimto_{\GF} \unravel{B}, \elemtuptupleb$.
  \end{itemize}
\end{restatable}
\begin{proofsketch}
  The unraveling is a forest model.
  The set $\{(\pi[\elemtuptuplex], \elemtuptuplex):\, \elemtuptuplex\ \text{is a live tuple in}\ \unravel{A} \}$ is an $\FGF$-bisimulation between $\unraveldom{A}, \elemtuptuplea$ and $\str{A}, \elemtuplea$.
  To construct a $\GF$-bisimulation between $\unravel{A}, \elemtuptuplea$ and $\unravel{B}, \elemtuptupleb$, we employ the auxiliary notion of ``histories'': for an element $e \in \unraveldom{A}$ with $\seq{e} = \elemtuples^{(0)}\cdots(i^{(n)}, j^{(n)})\elemtuples^{(n)}$, we define $\mathsf{hist}(e) = \tp{\FGF}{\str{A}}{\elemtuples^{(0)}} \cdots (i^{(n)}, j^{(n)}) \tp{\FGF}{\str{B}}{\elemtuples^{(n)}})$.
  Now let $\bisimZ \subseteq \PartIso{\unravel{A}}{\unravel{B}}$ be the set such that $(\elemtuptuples, \elemtuptuplet) \in \bisimZ$ if:
  \begin{itemize}
    \item $\elemtuptuples$, $\elemtuptuplet$ are live tuples of size $k$ from $\unravel{A}$, $\unravel{B}$, and
    \item $\mathsf{hist}(s_{i}) = \mathsf{hist}(t_{i})\text{ and }\ctr{s_{i}} = \ctr{t_{i}}\text{ for all }i \in [1, k]$
  \end{itemize}
  This set is a $\GF$-bisimulation.
  A detailed proof of this is given later for the finite case.
\end{proofsketch}
\begin{proof}
  \bfbox{todo proof for infinite unraveling theorem}
\end{proof}

Now, the theorem stated in the introduction of this chapter is a simple corollary:
\thminfupgrading
\begin{proofsketch}
Since unravelings are $\FGF$-bisimilar to their base structure, if $(\unravel{A}, \elemtuptuplea) \bisimto_{\FGF} (\unravel{B}, \elemtuptupleb)$, then also $(\str{A}, \elemtuplea) \bisimto_{\FGF} (\str{B}, \elemtupleb)$ by transitivity of bisimilarity.
The claim then directly follows from \cref{thm:inf-unraveling-upgrading}.
\end{proofsketch}
