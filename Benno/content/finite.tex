\chapter{Finite Companions}\label{chap:finite}
The goal in this chapter is to develop finite companions, as required for the proof of \cref{thm:main-technical-thm}.
Let $\unravel{A}, \elemtuptuplea$ be the tree unraveling of a finite structure $\str{A}, \elemtuplea$.
As finite companion for $(\str{A}, \elemtuplea)$ we use the \emph{finite $\ell$-unravelings} $\unravel{A}_{\ell}, \elemtuptuplea_{\ell}$ for a number $\ell$ which is a structure that is $\ell$-$\FGF$-bisimilar to $\unravel{A}, \elemtuptuplea$ (and hence $\ell$-$\FGF$-bisimilar to $\str{A}, \elemtuplea$ by transitivity of bisimilarity).
The precise construction of this $\ell$-unraveling is the topic of this chapter.
The main idea is to take the (possibly infinite) trees generated by the unraveling described in the previous chapter and cut them at some depth.
The criteria that we employ for this cutting is the level of biseqs.
For an element $r \in \unraveldom{A}$, we construct the finite tree $\mathcal{T}_{r,\ell}(\unravel{A})$ as follows:
\begin{equation*}
  \mathcal{T}_{r,\ell}(\unravel{A}) = \left\{ e \in \unraveldom{A}:\, e\ \text{is a descendant of $r$ and the level of $\seq{e}$ is at most $2 * \ell$} \right\}.
\end{equation*}
\Cref{fig:cutting} illustrates this construction.
\begin{figure}[H]%
  \centering
  \input{res/cutting}
  \caption{Cutting the tree unraveling to obtain a finite tree and numbering missing children}\label{fig:cutting}
\end{figure}%

\noindent
The set $\mathcal{T}_{r,\ell}(\unravel{A})$ with the $\relNext$ relation is a tree with the root $r$, because for every element $e \in \mathcal{T}_{r,\ell}(\str{A}) \setminus \{r\}$, its parent $p$ is also in $\mathcal{T}_{r,\ell}(\unravel{A})$.
This follows from the following two obvervations:
\begin{itemize}
  \item $p$ is a descendant of $r$, since $e$ is a descendant of $r$ and $e \neq r$, and
  \item since $p$ is a parent of $e$, the level of $\seq{p}$ is lower or equal to the level of $\seq{e}$ (which is at most $2 * l$ because $e \in \mathcal{T}_{r,\ell}(\unravel{A})$), and hence the level of $\seq{p}$ is at most $2 * \ell$ as well.
\end{itemize}
Furthermore, this tree is finite:
\input{proofs/bounded-trees-are-finite}
\noindent
We now consider the collection of finite trees with roots that have a ``short'' biseq, more precisely with roots which in the set $\mathcal{S} = \left\{ \mathcal{T}_{r,\ell}(\str{A}):\, r \in A \text{ and } \seq{r}\ \text{has level at most $\ell$}\right\}$.
This set is finite, by the same argumentation as in the proof of \cref{lem:bounded-trees-are-finite}.
The trees in the set $\mathcal{S}$ are exactly those trees for which we can guarrantee that the shortest path from the root to any leaf with a biseq of level $2 * \ell$ has at least length $\ell$.
\begin{lemma}\label{lem:bounded-trees-shortest-next-path}
  If $r \in \unraveldom{A}$ is an element with a biseq of level at most $\ell$, and $e \in \mathcal{T}_{r,\ell}(\str{A})$ is a leaf with a biseq of exactly level $2 * \ell$, then the shortest next-path from $r$ to $e$ has length at least $\ell$.
\end{lemma}
\begin{proof}
  For any elements $(a,b) \in \relNext$, the level of $\seq{b}$ is at most one more than the level of $\seq{a}$.
  If the level of $\seq{r}$ is at most $\ell$, and $e$ is an element where the level of $\seq{e}$ is $2 * \ell$, then the difference between both levels is at least $\ell$.
  It follows that any next chain from $r$ to $e$ must go through at least $\ell$ $\relNext$-edges, so it has length at least $\ell$.
\end{proof}
Next we construct a structure which for all $\mathcal{T} \in \mathcal{S}$, has a number of distinct, isomorphic copies of the substructure $\restr{\unravel{A}}{\mathcal{T}}$ (we say precisely how many copies we need later).
This is shown in \cref{fig:finite-unraveling}.
Take any tree $\mathcal{T} \in \mathcal{S}$.
We say that $b \in \unraveldom{A}$ is a \emph{missing child} of $a \in \mathcal{T}$ if $b$ is a child of $a$ in $\unravel{A}$ but $b \notin \mathcal{T}$.
Intuitively, if $b$ is a missing child of $a$, then this is because the biseq of $b$ has a level greater than the bound $2 * \ell$.
Due to missing children, the structure constructed so far is not $\FGF$-equivalent to the original structure, as these children are missing as witnesses for the $\FGF$-game.
To fix this, we replace each missing child $b$ with an element that is similar, but has a shorter biseq.
The element we choose for this is a root of a copy of a tree in $\mathcal{S}$ with a biseq equal to the level-$\ell$ suffix of the biseq of the original child $b$.
If we view biseqs as representing a history of game play in $\FGF$-game, this corresponds to forgetting all except the last $\ell$ moves.
We take care to ensure that for any given tree $\mathcal{T}$ in $\mathcal{S}$, two missing children are always replaced by roots of distinct copies of trees in $\mathcal{S}$.

\begin{figure}
  \centering
  \input{res/finite-unraveling}
  \caption{Construction of the finite unraveling. First, the trees of the infinite unraveling are cut at biseq level $2*\ell$, and all the missing children are labelled with indices $1, \ldots, M$ (as shown in the left part of the above picture). Then, any $\relNext$-link to a missing child is replaced with a link to the corresponding copy (as shown in the right part of the picture) of the tree that is similar to the subtree originally rooted at the position of the missing child.}
  \label{fig:finite-unraveling}
\end{figure}

We make the replacement of missing children precise with the following definition of the \emph{finitary $\relNext_{\ell}$ relation}.
We assign an \emph{associated index} to each of the missing children such that no missing children $b_{1}$ and $b_{2}$ from the same tree in $\mathcal{S}$ share the same associated index.
One possible way to do this is as follows.
For each tree, we form a sequence of all the missing children, by enumerating them in an arbitrary order.
We then label the missing children with their index in such a sequence.

We assume that our structure contains enough copies of each tree $\mathcal{T} \in \mathcal{S}$ such that for any associated index $i$, we can uniquely assign a distinct copy of $\mathcal{T}$ to such an index $i$.
We call such a copy the \emph{$i$-th copy of the tree $\mathcal{T}$}.
Let $\mathcal{T}^{*}$ be any copy of the tree $\mathcal{T} \in \mathcal{S}$ and $a^{*} \in \mathcal{T}^{*}$ be the copy of the element $a \in \mathcal{T}$.
We define $\relNext_{\ell}$ such that $(a^{*}, b^{*}) \in \relNext_{\ell}$ for a copy $b^{*}$ of some $b \in \unraveldom{A}$ if:
  \begin{itemize}
    \item $(a,b) \in \relNext$ and $b^{*} \in \mathcal{T}^{*}$, \ie{} $b^{*}$ is in the same tree as $a^{*}$, or
    \item
          $(a,a') \in \relNext$, where $a'$ is a missing child with associated index $m$, and its replacement $b^{*}$ satisfies all of the following:
          \begin{enumerate}
            \item $b^{*}$ is the root of the $m$-th copy of some tree in $S$,
            \item $\ctr{b} = \ctr{a'}$, and
            \item $\seq{b}$ is the level-$\ell$ suffix of $\seq{a'}$.
          \end{enumerate}
  \end{itemize}

Finally, to construct the \emph{finite $\ell$-unravelings}, we only take those copies of trees which are either rooted at an element with sequence level equal to zero and counter equal to one or are needed to replace missing children.
This is made precise in the following definition.
\begin{definition}[Finite $\ell$-Unraveling]\label{def:finite-tree-unraveling}
  Let $\unravel{A}$ be an unraveling of $\str{A}$, $\mathcal{S}$ be the set of trees $\mathcal{S} = \left\{ \mathcal{T}_{r,\ell}(\str{A}):\, r \in A \text{ and } \seq{r}\ \text{has level at most $\ell$}\right\}$, and
  $M$ be the maximum associated index of any missing child of any tree $\mathcal{T}_{r,\ell} \in \mathcal{S}$.

  The \emph{finite $\ell$-unraveling} $\unravel{A}_{\ell}$ is a structure with the domain $\unraveldom{A}_{\ell}$ consisting of $M$ isomorphic, disjoint copies of each tree $\mathcal{T}_{r,\ell}$ from $\mathcal{S}$, subject to the following restriction: each element $e \in \unraveldom{A}_{\ell}$ either has counter equal to one and sequence level equal to zero or is reachable via a $\relNext_{\ell}$-chain from such an element.
  The relations in $\unravel{A}_{\ell}$ follow the same conditions as in \cref{def:tree-unraveling} (infinite tree unraveling), but with $\relNext$ replaced by its finitary variant $\relNext_{\ell}$.
\end{definition}

\noindent
The structure $\unravel{A}_{\ell}$ is tree-like, in the sense of the following lemma:
\input{proofs/companion-tree-like}

In the following, let $\elemtuplea \isoeq \elemtupleb$ denote that $\restr{\str{A}}{\set(\elemtuplea)}$ is isomorphic to $\restr{\str{B}}{\set(\elemtupleb)}$, for tuples $\elemtuplea$ and $\elemtupleb$ from some structures $\str{A}$ and $\str{B}$.
Consider two tuples with equal atomic forward types from two $\ell$-unravelings.
We employ \cref{lem:companion-tree-like} to show that if $\ell$ is sufficient large, this means that those two tuples are in fact isomorphic.
\input{proofs/fgf-type-iso}

Our main goal for the remainder of this section is to show that $\unravel{A}_{\ell} \bisimto_{\GF}^{n} \unravel{B}_{\ell}$, given that $\str{A} \bisimto_{\FGF}^{m} \str{B}$ for some $m$ and $\ell$ which depend only on $n$.
For this proof, we first introduce the notion of $z$-\emph{similar} elements for $z \in \N$, which is a relation between elements from $\unravel{A}_{\ell}$ and $\unravel{B}_{\ell}$.
We later lift this relation to tuples to construct the $n$-$\GF$-bisimulation.
Intuitively, the idea behind the notion of $z$-similarity is to relate elements which behave similar for up to $z$ transitions along $\relNext$-edges, in both forward and backward direction.
In other words, our notion of $z$-similarity ensures that if $a \in \unraveldom{A}_{\ell}$ and $b \in \unraveldom{B}_{\ell}$ are $z$-similar elements, then for every parent (or child) $c \in \unraveldom{A}_{\ell}$ of $a$, there exists a parent (or child) $d \in \unraveldom{B}_{\ell}$ of $b$ which is $(z{-}1)$-similar to $c$.
Let us first consider the simpler case of only achieving this property for children (i.e.\ forward transitions along $\relNext$-edges).
We say that elements $a \in \unraveldom{A}_{\ell}$ and $b \in \unraveldom{B}_{\ell}$ are $z$-\emph{forward-similar} if $\ctr{a} = \ctr{b}$, $\seq{a} = \cdots \elemtuples$ and $\seq{b} = \cdots \elemtuplet$ for tuples $\elemtuples$ and $\elemtuplet$ that satisfy $\tp{\FGF_{z}}{\str{A}}{\elemtuples} = \tp{\FGF_{z}}{\str{B}}{\elemtuplet}$.
Note that $\tp{\FGF_{z}}{\str{A}}{\elemtuples} = \tp{\FGF_{z}}{\str{B}}{\elemtuplet}$ is equivalent to $\str{A}, \elemtuples \bisimto_{\FGF}^{z} \str{B}, \elemtuplet$ by \cref{lem:FGF-bisimulations-work-well}.
If we have such $z$-forward-similar elements $a$ and $b$ and $c \in \unraveldom{A}_{\ell}$ is a child of $a$, then by definition of $\relNext_{\ell}$ there are two possible situations: either (\romannumeral1) $c$ has the same sequence as $a$ but an incremented counter, or (\romannumeral2) $c$ adds a move to the sequence of $a$ (possibly removing elements from the beginning of the sequence if the result is too long).
In both cases, we can find a child $b$ that is $(z{-}1)$-forward-similar to $c$: in case (\romannumeral1) we simply increment the counter of $b$, whereas in case (\romannumeral2) we employ~\ref{bisim:fforth} to find a move in $\str{B}$ that we can add to the end of the sequence of $b$ to obtain a child $d$ of $b$ so that the (new) last tuples of $\seq{c}$ and $\seq{d}$ have equal $\FGF_{z{-}1}$-types.

We now consider the general case, including backward transitions.
As we saw above, forward transitions along $\relNext$-edges extend the sequence of an element by adding moves to the end.
If we allow backward transitions, then we need to consider the opposite case: that moves are removed from the end of the sequence.
It is thus no longer sufficient to only look at the type of the last tuple in a sequence.
Instead, we need to consider the types of the last $z$ tuples.
Intuitively, we obtain the history of an element by replacing the individual tuples $\elemtuples^{(0)}, \elemtuples^{(1)}, \ldots$ in the biseq with their $\FGF_{z}$-types $\tp{\FGF_{z}}{\str{A}_{\ell}}{\elemtuples^{(0)}}, \tp{\FGF_{z}}{\str{A}_{\ell}}{\elemtuples^{(1)}}, \ldots$ and truncating this sequence to its last $z$ steps:
\begin{definition}[$z$-history]
  Let $\str{A}$ be a structure, $\ell \in \N$ and $a \in \unraveldom{A}_{\ell}$ be an element with $\seq{a} = \elemtuples^{(0)} \cdots (i^{n}, j^{n})\elemtuples^{n}$ for some $n \in \N$, tuples $\elemtuples^{(0)}, \ldots, \elemtuples^{(n)}$ and indices $i^{(1)}, \ldots, i^{(n)}$ and $j^{(1)}, \ldots, j^{(n)}$.\\
  The \emph{$z$-history} of $a$, denoted by $\hist{z}{a}$, is the following sequence:
  \begin{equation*}
    \hist{z}{a} =
      \Gamma_{n-h}
      \,
      (i^{(n-h+1)}, j^{(n-h+1)})
      \,
      \Gamma_{n-h+1}
      \
      \cdots
      \
      (i^{(n)}, j^{(n)})
      \,
      \Gamma_{n}
  \end{equation*}
  where $\Gamma_{i} = \tp{\FGF_{z}}{\str{A}_{\ell}}{\elemtuples^{(i)}}$ for all $i \in [0,n]$ and $h = \min(z, n)$. \\[0.5ex]
  If $h < z$, then $\hist{z}{a}$ is called a \emph{short $z$-history}.
\end{definition}
In the case that the original sequence already has less than $z$ steps, then the truncation to the last $z$ steps does nothing and we get a short $z$-history, also with less than $z$ steps.
This definition is analogous to a construction used by Otto in the upgrading from global bisimulation to two-way global bisismulation for modal logic~\cite[Def. 39]{Otto04}.
Histories can be compared across unravelings of different structures, since they no longer refer to concrete elements from the base structure.
For two finite unravelings $\str{A}_{\ell}$ and $\str{B}_{\ell}$ of different base structures $\str{A}$ and $\str{B}$, we define \emph{$z$-similar elements} to be those elements which have equal $z$-histories and equal counters.
\begin{definition}[$z$-similar elements]
 Let $e \in \unraveldom{A}_{\ell}$ and $f \in \unraveldom{B}_{\ell}$ be bipoints, and $z$ be a natural number. Then $e$ and $f$ are \emph{$z$-similar}, written $e \approx_{z} f$, if $\ctr{e} = \ctr{f}$ and $\hist{z}{e} = \hist{z}{f}$.
\end{definition}
Note that if $e$ and $f$ are $z$-similar and $\hist{z}{e}$ is a short $z$-history, then $\hist{z}{f}$ must also be a short $z$-history.
So if either $\seq{e}$ or $\seq{f}$ has a level smaller than $z$, then $\seq{e}$ and $\seq{f}$ have equal level.
Compared to the notion of $z$-forward-similarity, note that $z$-similarity requires not just the $\FGF_{z}$-type of the last tuple in the sequences to match.
Rather, it additionally requires that the types of the $z$ last tuples of the sequences are equal.
Because of this, $z$-similar elements have both $(z{-}1)$-similar children and $(z{-}1)$-similar parents, as we prove with the next lemma.
\input{proofs/approx-next}

\noindent
We now lift the notion of $z$-similarity from elements to tuples of elements, with the following definition.
\begin{definition}[tuples of $z$-similar elements]
Let $\elemtuptuplea \sqin \unraveldom{A}_{\ell}$ and $\elemtuptupleb \sqin \unraveldom{B}_{\ell}$ be live tuples of equal size $k$ with $\elemtuptuplea = (a_{1}, \ldots, a_{k})$ and $\elemtuptupleb = (b_{1}, \ldots, b_{k})$.
We say that $\elemtuptuplea$ and $\elemtuptupleb$ are \emph{tuples of $z$-similar elements} if $a_{i} \approx_{z} b_{i}$ for every $i \in [1,k]$.
\end{definition}
We show that tuples of $z$-similar elements have the same atomic-$\FGF$-type, which further implies by \cref{lem:fgf-type-iso} that they are isomorphic.
\begin{lemma}\label{lem:tuple-sim-eq-atp}
  Let $\unravel{A}_{\ell}$ and $\unravel{B}_{\ell}$ be finite unravelings of structures $\str{A}$ and $\str{B}$ for an arbitrary $\ell \in \N$.
  If $\elemtuptuplea \sqin \unraveldom{A}_{\ell}$ and $\elemtuptupleb \sqin \unraveldom{B}_{\ell}$ are tuples of $z$-similar elements for some $z \in \N$, then $\atp{\FGF}{\unravel{A}_{\ell}}{\elemtuptuplea} = \atp{\FGF}{\unravel{B}_{\ell}}{\elemtuptupleb}$.
\end{lemma}
\begin{proof}
  Take tuples $\elemtuptuplea$ and $\elemtuptupleb$ of $z$-similar elements from unravelings $\unravel{A}_{\ell}$ and $\unravel{B}_{\ell}$.
  Let $\elemtuples$ and $\elemtuplet$ be the tuples from $\str{A}$ and $\str{B}$ such that $\seq{a_{k}} = \cdots \elemtuples$ and $\seq{b_{k}} = \cdots \elemtuplet$.
  Since $a_{k} \approx_z b_{k}$, we know that $\elemtuples$ and $\elemtuplet$ have the same atomic-$\FGF$-type.
  Observe that $\pi[\elemtuptuplea] = \elemtuples_{(\ctr{a_{k}}-k)\ldots{}\ctr{a_{k}}}$ and likewise $\pi[\elemtuptupleb] = \elemtuplet_{(\ctr{b_{k}}-k)\ldots{}\ctr{b_{k}}}$.
  This follows from \cref{lem:next-is-consecutive} since $\elemtuptuplea$ and $\elemtuptupleb$ are live and thus must be next-chains.
  As $\ctr{a_{k}} = \ctr{b_{k}}$, both $\elemtuptuplea$ and $\elemtuptupleb$ project to infixes $\elemtuples_{i\ldots{}j}$ and $\elemtuplet_{i\ldots{}j}$ over the common range $i\ldots{}j$ for $i = \ctr{a_{k}} - k$ and $j = \ctr{a_{k}}$.
  Hence, atomic-$\FGF$-types of $\pi[\elemtuptuplea]$ and $\pi[\elemtuptupleb]$ are also equal.
  Now consider an infix $\elemtuptuplea_{x\ldots{}y}$ and the corresponding infix $\elemtuptupleb_{x\ldots{}y}$, for some indices $x$ and $y$.
  Our claim is that $\elemtuptuplea_{x\ldots{}y}$ and $\elemtuptupleb_{x\ldots{}y}$ are in the same relations.
  We prove this claim by examining the three conditions of the definition of relations in the unraveling in turn.
  We show that each condition is true for $\elemtuptuplea_{x\ldots{}y}$ if and only if it is true for $\elemtuptupleb_{x\ldots{}y}$.
  Let $\relR$ be any relational symbol. Then:
  \begin{enumerate}
    \item $\pi[\elemtuptuplea_{x\ldots{}y}] \in \relR^{\str{A}}$ if and only if $\pi[\elemtuptuplea_{x\ldots{}y}] \in \relR^{\str{B}}$, because $\pi[\elemtuptuplea]$ and $\pi[\elemtuptupleb]$ have equal atomic-$\FGF$-types,
    \item $\elemtuptuplea_{x\ldots{}y}$ is a next-chain if and only if $\elemtuptupleb_{x\ldots{}y}$ is a next-chain, because both infixes are always next-chains since $\elemtuptuplea$ and $\elemtuptupleb$ are next-chains as they are live,
    \item $|\elemtuptuplea_{x\ldots{}y}| \le \bound{\elemtuptuplea_{x\ldots{}y}}$ if and only if $|\elemtuptupleb_{x\ldots{}y}| \le \bound{\elemtuptupleb_{x\ldots{}y}}$ because $|\elemtuptuplea_{x\ldots{}y}| = |\elemtuptupleb_{x\ldots{}y}| = y-x+1$ and $\bound{\elemtuptuplea_{x\ldots{}y}} = \bound{\elemtuptupleb_{x\ldots{}y}}$ since $\ctr{a_{j}} = \ctr{b_{j}}$ follows from $a_{j} \approx_{z} b_{j}$.
  \end{enumerate}
  Therefore, infixes of $\elemtuptuplea$ and $\elemtuptupleb$ are in the same relations.
  We conclude that $\elemtuptuplea$ and $\elemtuptupleb$ have equal $\FGF$-types.
\end{proof}
Combining the result of with \cref{lem:fgf-type-iso}, we get the following corollary:
\begin{corollary}\label{cor:tuple-similar-iso}
  Let $\elemtuptuplea$ and $\elemtuptupleb$ be live tuples of size $k$ in finite unravelings $\unravel{A}_{\ell}$ and $\unravel{B}_{\ell}$ for structures $\str{A}$, $\str{B}$ and some $\ell \in \N$.
  If $\ell > \arity(\Sigma)$ and $a_{i} \approx_{z} a_{i}$ for all $i \in [1,k]$ and some $z \in \N$, then $\elemtuptuplea \isoeq \elemtuptupleb$, as witnessed by the isomorphism $\mu_{(\elemtuptuplea, \elemtuptupleb)}:\, a_{i} \mapsto b_{i}$ for every $i \in [1, k]$.
\end{corollary}
Finally, we employ these isomorphisms to construct an $n$-$\GF$-bisimulation between finite unravelings.
\input{proofs/finite-unravel-gf-bisim}

The previous lemma shows that the finite $\ell$-unravelings satisfy the requirements laid out for the finite companions in \cref{sec:van-benthem-theorem}.
We collect the result in the following theorem, the main technical theorem of this work.
\maintechnicalthm
\begin{proof}
  Let $W = \arity(\Sigma)$. We define $\homop(\ell) := 2 * W * \ell$ for all $\ell \in \N$.
  Then for structures $(\str{A}, \elemtuplea)$ and $(\str{B}, \elemtupleb)$, the finite $W * \ell$-unravelings $(\unravel{A}_{W * \ell}, \elemtuptuplea)$ and $(\unravel{B}_{W * \ell}, \elemtuptupleb)$ provide the required companions.
  Indeed:
  \begin{itemize}
    \item The unravelings are finite by design.
    \item The $\ell$-$\GF$-bisimilarity is exactly the statement of \cref{lem:finite-unravel-gf-bisim}.
    \item The $\FGF$-bisimilarity between $(\str{A}, \elemtuplea)$ and the unraveling $(\unravel{A}_{W * \ell}, \elemtuplea)$ (and similar for $\str{B}$) is witnessed by the following bisimulation~$\mathcal{Z}$:
          \begin{equation*}
            \mathcal{Z} = \{ (\elemtuples, \elemtuptuples):\, \elemtuples \sqin A, \elemtuptuples \sqin \unraveldom{A}, \elemtuptuples \text{ is live and } \elemtuples = \pi[\elemtuptuples] \}
          \end{equation*}
  \end{itemize}
\end{proof}
