%!TEX root = ../main.tex
\chapter{Logics}\label{chap:logics}

In this chapter, we give a short review of first order logic and some of its fragments.
The goal is to make the thesis self-contained, for a more complete treatment of these topics we refer to appropriate textbooks~\cite{Libkin04,monk1976}.
We also fix the notation that we employ in the later chapters.
For quick reference, \cref{fig:notation-quickref} summarizes all notation appearing throughout the thesis.
\begin{figure}[p]
  \centering
  \bgroup
  \def\arraystretch{1.1}
  \begin{tabularx}{\textwidth}{c X r}
    notation & meaning & introduced in \\
    \hline
    $\str{A}$, $\str{B}$, \ldots & structures with domains $A$, $B$, \ldots & \cref{chap:logics} \\
    $\Sigma$ & the fixed, purely relational signature of structures unless stated otherwise & \cref{chap:logics} \\
    $\arity(\Sigma)$ & the maximum arity among all predicates in $\Sigma$ (width of $\Sigma$) & \cref{chap:logics} \\
    $\elemtuplea, \elemtupleb$, \ldots & tuples of elements & \cref{chap:logics} \\
    $\elemtuptuplea, \elemtuptupleb$, \ldots & tuples of tuples / tuples of elements from unravelings & \cref{chap:logics} \\
    $f[\elemtuplea]$ & componentwise-image of $f$ on $\elemtuplea$, i.e.\ $(f(a_{1}), \ldots, f(a_{n}))$ & \cref{chap:logics} \\
    $\tp{\logicL}{\str{A}}{\elemtuplea}$ & $\logicL[\sigma]$-type of $\elemtuplea$ in $\str{A}$ (all $\logicL[\sigma]$-formulaes satisfied by $\elemtuplea$) & \cref{chap:logics} \\
    $\atp{\logicL}{\str{A}}{\elemtuplea}$ & atomic-$\logicL[\sigma]$-type of $\elemtuplea$ in $\str{A}$ & \cref{chap:logics} \\
    $\logicL_{\ell}$ & logic $\logicL$ restricted to formulae with quantifier rank at most $\ell$ & \cref{chap:logics} \\
    $\str{A}, \elemtuplea \bisimto_{\FGF} \str{B}, \elemtupleb$ & an $\FGF$-bisimulation containing $(\elemtuplea, \elemtupleb)$ exists between $\str{A}$ and $\str{B}$ & \cref{chap:logics} \\
    $\str{A}, \elemtuplea \bisimto_{\FGF}^{\ell} \str{B}, \elemtupleb$ & an $\ell$-$\FGF$-bisimulation containing $(\elemtuplea, \elemtupleb)$ exists between $\str{A}$ and $\str{B}$ & \cref{chap:logics} \\
    $\unravel{A}$ & the (possibly infinite) tree unraveling of $\str{A}$ & \cref{chap:unraveling} \\
    $\unravel{A}_{\ell}$ & the finite unraveling of $\str{A}$ for threshold $\ell$ & \cref{chap:finite} \\
    $\relNext$ & the parent-child relation in the tree unraveling & \cref{chap:unraveling} \\
    $\relNext_{\ell}$ & finitary variant of $\relNext$, used for defining $\unravel{A}_{\ell}$ & \cref{chap:finite} \\
    $\seq{a}$ & sequence part of an unraveling element, i.e.\ $\sigma$ for $a = (\sigma, k)$ & \cref{chap:unraveling} \\
    $\ctr{a}$ & counter part of an unraveling element, i.e.\ $k$ for $a = (\sigma, k)$ & \cref{chap:unraveling} \\
    $\bound{\elemtuptuplea}$ & counter of the last component of $\elemtuptuplea$, i.e.\ $\ctr{a_{|\elemtuptuplea|}}$ & \cref{chap:unraveling} \\
  \end{tabularx}
  \egroup
  \caption{Overview of relevant notation. For completeness, we include notation introduced in later chapters.}%
  \label{fig:notation-quickref}
\end{figure}

\begin{figure}[p]
  \begin{example*}
    \newcommand\relDouble{\rel{\texttt{Double}}}
    \newcommand\relRed{\textcolor{tolhighcontrastRed}{\rel{Red}}}
    \newcommand\relBlue{\textcolor{tolhighcontrastBlue}{\rel{Blue}}}
    \newcommand\relYellow{\textcolor{tolhighcontrastYellow}{\rel{Yellow}}}
    Consider a signature $\sigma$ composed of four relational symbols: an unary symbol $\relDouble$, a binary symbol $\relRed$, a 3-ary symbol $\relBlue$ and a 4-ary symbol $\relYellow$.
    We define a $\sigma$-structure $\str{A}$ over the domain $A = \{1,2,3\}$ with $\relDouble^{\str{A}} = \{2\}$, $\relRed^{\str{A}} = \{(1,2), (2,3)\}$, $\relBlue^{\str{A}} = \{ (1,3,2) \}$ and $\relYellow^{\str{A}} = \{ (1,1,2,3)\}$.
    We visualize this structure in the following picture, with relations indicated by colored edges (except for $\relDouble$, which we indicate using a double border):
    \begin{center}
    \input{res/ex-struct}
    \end{center}
  \end{example*}
  \caption{An example structure, visualized as directed hypergraph\hfill{}}\label{fig:struct-1}
\end{figure}

We start with basic mathematical notation for tuples.
An $n$-\emph{tuple} is a list of $n$ components $a_{1}, \ldots{}, a_{n}$.
We use overlined letters like $\elemtuplea$, $\elemtupleb$ for tuples, except when the components are tuples themselves, in which case we use arrows, as in $\elemtuptuplea$.
We denote the set of components of a tuple $\elemtuplea$ by $\set(\elemtuplea)$.
We write $\emptytupl$ for the tuple with zero components.
For a set $S$, we write $\elemtuplea \sqin S$ iff $\elema_i \in S$ for all indices $1 \leq i \leq |\elemtuplea|$, where $|\elemtuplea|$ denotes the length of~$\elemtuplea$.
We use $\elemtupleafromto{i}{j}$ to denote the $(j{-}i{+}1)$-tuple $\elema_i, \elema_{i+1}, \ldots, \elema_j$.
Conversely, we say that a tuple $\elemtupleb$ is an infix of a tuple $\elemtuplea$ if there exists indices $i$ and $j$ such that $\elemtupleb = \elemtupleafromto{i}{j}$.
We use the notation ``$\cdots e$'' for a tuple where the last element is equal to $e$ and preceding elements are not important.
For a function $f$ and tuple $\elemtuplea_{1\ldots\ell}$, we write $f[\elemtuplea_{1\ldots\ell}]$ for the tuple $(f(a_{1}), \ldots, f(a_{\ell}))$.

Next, we present the definition of a \emph{structure}.
We will not consider structures with function symbols in this thesis, hence we define a structures without function symbols here (compare \cite[Definition 2.1]{Libkin04}):
\begin{definition}[Structures]
  A \emph{signature} $\Sigma$ is a collection of constant symbols $c_{1}, \cdots, c_{k}$ and relational symbols $\relR_{1}, \ldots, \relR_{n}$.
  Each relational symbol $\relR$ has an associated arity, denoted by $\arity(\relR)$.
  A signature is \emph{purely-relational} if it contains no constant symbols.
  A $\Sigma$-\emph{structure} $\str{A} = (A, {\cdot\,}^{\str{A}})$ consists of a domain $A$ together with an interpretation function ${\cdot\,}^{\str{A}}$, which assigns:
  \begin{itemize}
    \item to each constant $c_{i} \in \Sigma$ an element $c_{i}^{\str{A}}$ in $A$, and
    \item to each $k$-ary relational symbol $\relR \in \Sigma$ a $k$-ary relation $\relR^{\str{A}}$ on $A$, that is a set $\relR^{\str{A}} \subseteq A^{k}$.
  \end{itemize}
  A structure $\str{A}$ is \emph{finite} if its domain $A$ is finite.
\end{definition}
We commonly visualize structures as directed hypergraphs, for an example see \cref{fig:struct-1}.

Given a structure $\str{A}$ and $B \subseteq A$, we use $\restr{\str{A}}{B}$ to denote the \emph{substructure} of $\str{A}$ with domain $B$ and relations appropriately restricted to this domain.
For a $\sigma$-structure $\str{A}$ and an element $a \in A$, we write $(\str{A}, a)$ for the $(\sigma \cup \{a\})$-structure that extends $\str{A}$ with an additional constant symbol $a$ interpreted as $a \in A$, and similar for tuples of elements $\elemtuplea$, where we introduce one constant for each component of the tuple.
We call a structure with distinguished elements constructed in this way a \emph{pointed structure}.
We say that a tuple $\elemtuplea \sqin A$ is \emph{live} in a $\sigma$-structure $\str{A}$ if $|\elemtuplea| \leq 1$ or~$\elemtuplea \in \relR^{\str{A}}$ for some predicate~$\relR \in \sigma$.
Most statements made in this thesis generalize to any finite and purely-relational signature $\Sigma$.
Thus, we now fix an arbitrary, finite and purely-relational signature $\Sigma$ and adopt the convention that the signature of all structures is $\Sigma$, unless stated otherwise.
Since $\Sigma$ is finite, there is a maximum arity of the relational symbols in $\Sigma$, which we denote by $\arity(\Sigma)$.
In this visualization, each element of the domain corresponds to a node in the graph.
For each relational symbol $\relR_{i} \in \Sigma$, we draw (hyper)edges labelled with $\relR_{i}$ between the elements which are in this relation according to its interpretation.
In examples, we use uppercase letters $\relE, ...$ as relational symbols which we assume to be part of $\Sigma$ for the purposes of these examples.

Now, we introduce \emph{first-order logic}, starting with the syntax of formulae, followed by the satisfaction relation between structures and formulae.
All the other logics considered in this thesis are fragments of first order logic.
\begin{definition}[Formulae of First-Order Logic, compare {\cite[Definition 2.2]{Libkin04}}]
  Let $\mathcal{V} := \{x_{1}, x_{2}, \ldots\}$ be a countably-infinite set of \emph{variables} and $\sigma$ be a signature.
  An \emph{atomic formula} (or short \emph{atom}) over $\sigma$ is an expression of one of the following forms:
  \begin{itemize}
    \item $c_{i}$ for a constant $c_{i} \in \sigma$, or
    \item $\relR_{i}(t_{1}, \ldots, t_{n})$ for a relational symbol $\relR_{i} \in \sigma$ with arity $n$, where $t_{i}$ for $i \in [1,n]$ is either a variable in $\mathcal{V}$ or a constant from $\sigma$.
  \end{itemize}
  A \emph{first-order formula} $\varphi$ over $\sigma$ is an expression formed according to the following rule:
  \begin{equation*}
    \varphi, \varphi' ::= \alpha
      \mid \neg \varphi
      \mid (\varphi \lor \varphi')
      \mid \exists{x_{i}}(\varphi)
  \end{equation*}
  where $\alpha$ can be any atomic formula over $\sigma$.
\end{definition}
We write $\FO$ for the set of all first-order formulae.
For first-order formulae $\varphi_{1}$ and $\varphi_{2}$, we use the standard shorthands:
\begin{multicols}{2}
  \begin{itemize}
    \item $\varphi_{1} \land \varphi_{2}$ for $\neg ((\neg \varphi_{1}) \lor (\neg \varphi_{2}))$
    \item $\forall{x_{i}}(\varphi)$ for $\neg\exists{x_{i}}(\neg \varphi)$
    \item $\varphi_{1} \to \varphi_{2}$ for $\neg \varphi_{1} \lor \varphi_{2}$
    \item $\varphi_{1} \iff \varphi_{2}$ for $(\varphi_{1} \to \varphi_{2}) \land (\varphi_{2} \to \varphi_{2})$
    \item $\top$ for $\alpha \lor \neg \alpha$, for an arbitrary atom $\alpha$
    \item $\bot$ for $\neg \top$
  \end{itemize}
\end{multicols}
\noindent
We omit parentheses where they are clear.
The \emph{quantifier rank} of $\varphi$, denoted by $\qr(\varphi)$, is the maximum number of nested quantifiers appearing in $\varphi$, inductively defined as follows:
\begin{itemize}
  \item $\qr(\alpha) = 0$ for any atom $\alpha$,
  \item $\qr(\exists{x_{i}}(\varphi)) = \qr(\varphi) + 1$,
  \item $\qr(\varphi_{1} \lor \varphi_{2}) = \mathsf{max}(\qr(\varphi_{1}), \qr(\varphi_{2}))$, and
  \item $\qr(\neg \varphi)  = \qr(\varphi)$.
\end{itemize}

\begin{samepage}%
\noindent%
The \emph{free variables} of a formula $\varphi$ are inductively defined as follows:
\begin{itemize}
  \item the free variables of an atom $\alpha = \relR_{i}(v_{1}, \ldots, v_{n})$ are exactly the variables $v_{1}, \ldots, v_{n}$,
  \item the free variables of $\neg \varphi$ are the same as those of $\varphi$,
  \item the free variables of $\varphi_{1} \lor \varphi_{2}$ are the union of the free variables of $\varphi_{1}$ and $\varphi_{2}$,
  \item the free variables of $\exists{x_{i}(\varphi)}$ are the free variables of $\varphi$ minus the variable $x_{i}$.
\end{itemize}
\end{samepage}
Variables which are not free are called bound.
We write $\varphi(\vartuplex)$ if $\vartuplex$ contains exactly the free variables of $\varphi$.
A \emph{sentence} is a formula without free variables.
Given a free variable $x_{i}$ of a formula $\varphi$, we can subsitute this free variable by a variable or constant $t$, as follows.
\begin{enumerate}
  \item First, rename instances of bound variables equal to $t$ to a new name.
  \item Second, replace all occurrences of $x_{i}$ by $t$.
\end{enumerate}
We write $\varphi[x_{i} \mapsto t]$ for the formula obtained this way.
Similarly, if $\vartupley$ is a $k$-tuple of distinct variables and $\elemtuplea$ is a $k$-tuple of constants, then $\varphi[\vartupley \mapsto \elemtuplea]$ is constructed from $\varphi$ by replacing each free variable $y_{i}$ with the constant $a_{i}$, for $1 \le i \le k$.

\begin{definition}[Models of First-Order Formulae]
  A $\sigma$-structure $\str{A}$ is a \emph{model} of a first-order sentence $\varphi$ over $\sigma$, written as $\str{A} \models \varphi$, in the following cases:
\begin{itemize}
  \item $\str{A} \models \relR_{i}(a_{1}, \ldots, a_{k})$ if $({a_{1}}^{\str{A}}, \ldots, {a_{k}}^{\str{A}}) \in \relR_{i}^{\str{A}}$ for $\relR_{i} \in \Sigma$ and constants $a_{1}, \ldots, a_{k}$.
  \item $\str{A} \models \neg \varphi$ if not $\str{A} \models \varphi$.
  \item $\str{A} \models \varphi_{1} \lor \varphi_{2}$ if $\str{A} \models \varphi_{1}$ or $\str{A} \models \varphi_{2}$.
  \item $\str{A} \models \forall{x_{i}} (\varphi(x_{i}))$ if $(\str{A}, a_{i}) \models (\varphi[x_{i} \mapsto a_{i}])$ for all $a_{i} \in A$
\end{itemize}
For a first-order formula $\varphi(\vartuplex)$, we write $\str{A}, \elemtuplea \models \varphi$ if $\str{A} \models \varphi[\elemtuplex \mapsto \elemtuplea]$ for a tuple $\elemtuplea \sqin A$ with $|\elemtuplea| = |\elemtuplex|$.
\end{definition}

We next introduce notation that we use for any logic $\logicL \subseteq \FO$, \ie{} a logic $\logicL$ that is $\FO$ or a fragment of $\FO$.
The set $\logicL_{\ell}$ is the set of all formulae of $\logicL$ with quantifier rank at most $\ell$, where the quantifier rank is defined according to the definition of $\logicL$.
The \emph{$\logicL$-type} of $\elemtuplea$ in $\str{A}$, denoted with~$\tp{\logicL}{\str{A}}{\elemtuplea}$, consists of all $\logicL$-formulae with free variables~$\vartuplexfromto{1}{n}$ that are satisfied by $\elemtuplea$ in $\str{A}$.
If we restrict the type to only atomic and negated atomic $\logicL$-formulae, we obtain the \emph{atomic-$\logicL$-type} of $\elemtuplea$ in $\str{A}$, denoted with~$\atp{\logicL}{\str{A}}{\elemtuplea}$.
The atomic-$\logicL$-type of $\elemtuplea$ is logically equivalent to the $\logicL_{0}$-type of $\elemtuplea$ in $\str{A}$.
We write $\str{A} \equiv_\logicL \str{B}$ if $\str{A}$ and~$\str{B}$ satisfy the same $\logicL$-sentences.
For pointed structures $(\str{A}, \elemtuplea), (\str{B}, \elemtupleb)$ with $n$-tuples $\elemtuplea$ and~$\elemtupleb$ we employ the notation $(\str{A}, \elemtuplea) \equiv_\logicL (\str{B}, \elemtupleb)$ to indicate that for all $\varphi \in \logicL$ with free variables $\vartuplex$ we have $\str{A} \models \varphi[\vartuplex \mapsto \elemtuplea]$ if and only if $\str{B} \models \varphi[\vartuplex \mapsto \elemtupleb]$.
If two structures $\str{A}, \elemtuplea$ and $\str{B}, \elemtupleb$ satisfy exactly the same first-order formulae, we write $\str{A}, \elemtuplea \equiv_{\FO} \str{B}, \elemtupleb$, and similar for fragments of $\FO$.

It is well-known that the satisfiability (\ie{} existence of any model) problem for a given first-order formula is undecidable\cite[Sec. 1.1]{borger1997}.
Trakhtenbrot's theorem states that this is even true over just finite models\cite{trakhtenbrot50}.
This motivated a study of fragments of first-order logic, for which satisfiability is decidable and ideally has low complexity.
The fragment studied in this thesis is the \emph{forward guarded fragment}~\cite[Sec. 3.1]{Bednarczyk21}.
For a better understanding of this fragment, in the following sections we first describe two related fragments, \emph{basic modal logic} and the \emph{guarded fragment}, before moving to the forward guarded fragment.

\section{Modal Logic}
Modal Logic has a long history, beginning already with Aristotle's study of statements containing the words ``necessary'' and ``possible''\cite{goldblatt2006}.
It has applications in many different fields, such as philosophy and linguistics\cite{vanBenthem2010-VANMLF-4}.
However, here we focus on its application to computer science, where modal logic is commonly employed to talk about the behaviour of a dynamic system, consisting of states with certain properties and a relation describing the possible transitions between those states.
We~define modal logic, with first-order semantics, as follows (compare \cite[Sec. 2.1.2]{otto2004a}):
\begin{definition}[Basic Modal Logic]
  Let $\sigma$ be a signature of unary relational symbols $p_{i}, \ldots, p_{n}$ and a single binary relational symbol $\relR$.
  A \emph{basic modal logic formula} $\varphi$ is an expression according to the following rule:
  \begin{equation*}
    \varphi ::= p_{i}
      \mid \neg \varphi
      \mid \varphi \lor \varphi
      \mid \Diamond(\varphi)
  \end{equation*}
  where $p_{i}$ may be any unary relational symbol.
  The \emph{translation} of a modal logic formula $\varphi$ to first-order logic formula $\varphi^{\FO}$ with exactly one free variable is defined inductively as:
  \begin{itemize}
    \item $(p_{i})^{\FO} = p_{i}(x)$,
    \item $(\neg \varphi)^{\FO} = \neg \varphi^{\FO}$,
    \item $(\varphi_{1} \lor \varphi_{2})^{\FO} = \varphi_{1}^{\FO} \lor \varphi_{2}^{\FO}$,
    \item $(\Diamond (\varphi))^{\FO} = \exists{y}(\relR(x,y) \land \varphi^{\FO}[x \mapsto y])$, and
  \end{itemize}
  For a modal formula $\varphi$, we write $\str{A}, a \models \varphi$ if $\str{A}, a \models \varphi^{\FO}$.
\end{definition}
We use $\ML$ to denote the set of all basic modal logic formulae.
For modal logic formulae $\varphi$ and $\psi$, we define $\Box(\varphi) := \neg \Diamond(\neg \varphi)$ and $\varphi \land \psi := \neg ((\neg \varphi) \lor (\neg \psi))$.
The satisfiability problem for basic modal logic is $\PSpace$-complete\cite{ladner1977}.
An interesting property of basic modal logic is that several of its extensions are still decidable.
Some common extensions for which this is the case are (see~\cite[Sec. 5.1]{goranko2007}):
\begin{itemize}
  \item
        \textbf{Multiple modalities}.
        Instead of having just a single binary relation $\relR$, we allow for multiple relations $\relR_1, \ldots, \relR_{n}$ and use a separate $\Box_{i}$ and $\Diamond_{i}$ operator for each binary relation $R_{i}$.
        The translation to $\FO$ is as expected: $(\Diamond_{i}(\varphi))^{\FO} = \exists{y}(\relR_{i}(x,y) \land \varphi^{\FO}[x \mapsto y])$.
  \item
        \textbf{Inverse modality}.
        This extension adds a new oeprator $\Diamond^{-}$, with the translation: $(\Diamond^{-}(\varphi))^{\FO} = \exists{y}(\relR(y,x) \to \varphi^{\FO}[x \mapsto y])$.
        Note how the arguments to $\relR$ are inverted in the first-order translation.
  \item
        \textbf{Global modality}.
        In addition to modal quantification, this extension also allows global quantification, with the new operator $\exists$.
        The translation to $\FO$ is: $(\exists \varphi)^{\FO} = \exists{x}(\varphi^{\FO})$.
\end{itemize}

\begin{example}
  Consider the following structure $\str{T}$:
  \begin{center}
  \input{res/modal-logic-ex}
  \end{center}
  We view this structure as a transition system: the elements are the states of the system and the relation $\relR$ encodes the possible transitions from a given state.
  The unary predicates $p_{c}$ (marked by a circle) and $p_{r}$ (marked by a rectangle) are properties of states.
  We say that a modal formula $\varphi$ is true at some \emph{state} $s \in T$ if $\str{T}, s \models \varphi$.
  Some properties of this structure that we can express with modal logic are:
  \begin{itemize}
    \item $p_{c}$ (``the state is circled''), true at states $d$ and $c$
    \item $\Diamond(p_{c})$ (``some successor state is a circled one''), true at states $a, b, d$.
    \item $\Diamond(\Box(p_{c}))$ (``there is a successor which only has circled successors''), true at states $a, b, d$.
    \item $\Box(\Diamond(p_{c}))$ (``all successors have at least one successor that is circled''), true at $c,d$.
    \item $(\Diamond(p_{r})) \to (\Diamond(p_{c}))$ (``if there is a successor which is a rectangle, then there is also a circled successor''), true at all states.
    \item $(\Diamond(\top)) \land (\Box(p_{c}))$ (``there is at least one successor and all successors are circled''), true at $d$.
    \item with inverse modality: $\Box^{-}(p_{r})$ (``all predecessors are rectangles''), true at $c$.
  \end{itemize}
\end{example}
% basic modal logic: ML
% various extensions possible
% - modal logics with multiple modalities
% - modal logic with global modality
% - modal logic with inverse modalities

\section{Guarded Fragment}
Inspired by modal logic, Andr√©ka et al.~\cite{AndrekaNB98} devised the guarded fragment, with the goal of generalizing modal logic to signatures of arity greater than two but preserving its nice model-theoretic properties.
We take the definition of the guarded fragment from~\cite{BednarczykJ22}:
\begin{definition}[Guarded Fragment]
  $\GF$ is the smallest fragment of $\FO$  such that:
  \begin{itemize}\itemsep0em
      \item Every atomic formula is in $\GF$;
      \item $\GF$ is closed under boolean connectives $\land, \lor, \neg, \to$;
      \item If $\varphi(\vartuplex, \vartupley)$ is in $\GF$, $\alpha(\vartuplex, \vartupley)$ is an atom containing all free variables of $\varphi$, and $\vartupley$ is a tuple of variables then both $\forall{\vartupley} \; (\alpha(\vartuplex, \vartupley) \to \varphi(\vartuplex, \vartupley))$ and $\exists{\vartupley} \; (\alpha(\vartuplex, \vartupley) \land \varphi(\vartuplex, \vartupley))$ are in $\GF$;
      \item If $\varphi(\varx)$ has only a single free-variable $\varx$, then $\forall{\varx}\; \varphi(\varx)$ and $\exists{\varx}\; \varphi(\varx)$ are in $\GF$.
  \end{itemize}
\end{definition}
The predicates $\alpha$ appearing in the 3rd item of the above definition are called the \emph{guard} for $\varphi$.
We~stress that in definition of a quantifier rank for $\GF$ we treat quantifiers $\exists{\vartuplex}$ introducing tuples of variables as a single quantifier (not as an abbreviation for a block of quantifiers).
We write $\GF_{\ell}$ for the subset of $\GF$ of formulae with at most quantifier rank $\ell \in \N$.
For example, $\forall{x_{1}x_{2}x_{3}} \relR(x_{1}, x_{2}, x_{3}) \in \GF_{1}$.
The satisfiability problem for $\GF$ is $\TwoExpTime$-complete~\cite{gradel1999a}.

\begin{example}
  Examples of formula which are in $\GF$:
  \begin{itemize}
    \item the formula $\exists{x_{1}x_{2}x_{3}}\; (\relR(x_{1}, x_{2}, x_{3}) \land \forall x_{4}(\relR(x_{4}, x_{4}, x_{1}) \to \relR(x_{1}, x_{4}, x_{1})))$,
    \item the tranlsation of every modal logic formulae, allowing for multiple, inverse and global modalities,
    \item $\forall{x_{1}x_{2}}\; (\relR(x_{1},x_{2}) \to \relR(x_{2},x_{1}))$ (``$\relR$ is symmetric''), and
    \item $\forall{x_{1}}\; (\relR(x_{1},x_{1}))$ (``$\relR$ is reflexive'').
  \end{itemize}
\end{example}
\begin{example}
  An example of a formula which is \emph{not} in $\GF$ is: $\exists{x_{1}x_{2}x_{3}}\; (\relE(x_{1}, x_{2}) \land \relE(x_{2}, x_{3}) \land \relE(x_{3}, x_{1}))$ (``there is a triangle in the graph represented by $\relE$''), because the guard $\relE(x_{1}, x_{2})$ does not cover the free variable $x_{3}$ of $\relE(x_{2},x_{3}) \land \relE(x_{1}, x_{3})$.
\end{example}

\section{Forward Guarded Fragment}

The \emph{forward guarded fragment}~\cite[Sec. 3.1]{Bednarczyk21} (or $\FGF$) restricts $\GF$ in a way that the allowed sequences of atoms are infixes of the sequence of already-introduced variables (in the order of their quantification).
We begin with the formal definition, followed by some examples.
\begin{definition}[Forward Guarded Fragment]
  $\FGF(n)$ for $n \in \N$ is the smallest fragment of $\FO$ such that:
  \begin{itemize}\itemsep0em
      \item An atom $\alpha(\vartuplex)$ belongs to $\FGF(n)$ if $\alpha$ is equality-free and $\vartuplex$ is an infix of $\vartuplexfromto{1}{n}$.
      \item $\FGF(n)$ is closed under boolean connectives $\land, \lor, \neg, \to, \iff$;
      \item If $\alpha$ and $\varphi$ are in $\FGF(n{+}k)$ for a positive $k$ where $\alpha(\vartuplex, \vartupley)$ is an atom containing all free variables of $\varphi$ and $\vartupley$ is a $k$-tuple of variables then $\forall{\vartupley} \; (\alpha(\vartuplex, \vartupley) \to \varphi(\vartuplex, \vartupley))$ and $\exists{\vartupley} \; (\alpha(\vartuplex, \vartupley) \land \varphi(\vartuplex, \vartupley))$ are both in $\FGF(n)$;
      \item If $\varphi(\varx_1) \in \FGF(1)$ has only a single free-variable $\varx_1$, then $\forall{\varx_1}\; \varphi$ and $\exists{\varx_1}\; \varphi$ are in $\FGF(0)$.
  \end{itemize}
\end{definition}
We use $\FGF$ to denote $\FGF(0)$. Note that $\FGF(0)$ is solely composed of sentences.

\begin{example}
A formula $\exists{x_1x_{2}x_{3}}\; [\relR(x_{1}, x_{2}, x_{3}) \land \forall{x_{4}x_{5}}(\relS(x_{3}, x_{4}, x_{5}) \to \relT(x_{4})) \land \exists{x_{3}}(\relR(x_{1}, x_{2}, x_{3}))]$ belongs to $\FGF$.
Moreover, first-order translations of modal logic formulae, allowing for multiple and global modalities (but not inverses) are also in $\FGF$.
In contrast, formulae $\exists{x_{1}}\; \relE(x_{1}, x_{1})$ and $\exists{x_{1}}\; (\forall{x_{2}} \relT(x_{1}, x_{2}))$ are not in $\FGF$.
For the former formula the reason is that the sequence $x_1x_1$ is not an infix of the sequence~$x_1$.
The latter formula is not even in $\GF$ as the sequence $x_{1}, x_{2}$ is not guarded.
\end{example}
% introduced by Bart et al, generalization of multi-modal logic global modalities but without inverse modalities
% state definition; followed by examples
% guarded version of the forward fragment
% SAT = FinSAT complexity: ExpTime
